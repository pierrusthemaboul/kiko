#!/usr/bin/env node
/**
 * Agent CHLOE - Production TikTok
 *
 * Transforme les clips en vid√©os TikTok:
 * 1. Format 9:16 avec fond flou
 * 2. Hook texte visible pendant 6 secondes
 * 3. Noms de fichiers lisibles
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const config = require('./config.json');

// Chemins
const INPUT_DIR = path.resolve(__dirname, config.storage.input);
const OUTPUT_DIR = path.resolve(__dirname, config.storage.output);
const LOGS_DIR = path.resolve(__dirname, config.storage.logs);

// Cr√©er les dossiers si n√©cessaire
[INPUT_DIR, OUTPUT_DIR, LOGS_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
});

// ============ LOGGING ============
function log(action, status, detail, reason = "") {
    const entry = {
        timestamp: new Date().toISOString(),
        agent: config.agent_name,
        action,
        status,
        detail,
        reason
    };

    // Console
    const icon = status === 'OK' || status === 'SUCCESS' ? '‚úÖ' :
                 status === 'FAILED' ? '‚ùå' :
                 status === 'PROCESS' ? '‚è≥' : 'üìù';
    console.log(`[CHLOE] ${icon} ${action}: ${detail}`);

    // Fichier log
    const logFile = path.join(LOGS_DIR, `chloe_${Date.now()}.json`);
    fs.writeFileSync(logFile, JSON.stringify(entry, null, 2));

    return entry;
}

// ============ PRODUCTION VID√âO ============
async function produceVideo(clip, videoInputPath) {
    return new Promise((resolve, reject) => {
        // Nom de sortie lisible bas√© sur la s√©lection MARC
        const outputFilename = `tiktok_${clip.readable_filename.replace('clip_', '')}`;
        const outputPath = path.join(OUTPUT_DIR, outputFilename);

        log("ENCODING", "PROCESS", `Production: ${outputFilename}`);
        console.log(`         Hook: "${clip.hook}"`);

        // Pr√©parer le hook texte pour FFmpeg
        // Wrap le texte si trop long (max 20 chars par ligne)
        const wrapText = (text, maxLen) => {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            for (const word of words) {
                if ((currentLine + ' ' + word).trim().length <= maxLen) {
                    currentLine = (currentLine + ' ' + word).trim();
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);

            return lines.join('\\n');
        };

        const wrappedHook = wrapText(clip.hook, 22);

        // √âchapper les caract√®res sp√©ciaux pour FFmpeg
        const escapedHook = wrappedHook
            .replace(/'/g, "'\\''")
            .replace(/:/g, "\\:")
            .replace(/\[/g, "\\[")
            .replace(/\]/g, "\\]");

        // Construire le filtre FFmpeg complexe
        const filterComplex = [
            // 1. Cr√©er le fond flou
            `[0:v]scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,boxblur=${config.video.bg_blur}:5[bg]`,
            // 2. Redimensionner le gameplay
            `[0:v]scale=-1:1920:force_original_aspect_ratio=decrease[fg]`,
            // 3. Superposer gameplay sur fond
            `[bg][fg]overlay=(W-w)/2:(H-h)/2[v1]`,
            // 4. Ajouter le hook texte (visible pendant X secondes)
            `[v1]drawtext=text='${escapedHook}':fontcolor=${config.hook.font_color}:fontsize=${config.hook.font_size}:x=(w-text_w)/2:y=${config.hook.position_y}:box=1:boxcolor=${config.hook.bg_color}@${config.hook.bg_opacity}:boxborderw=15:line_spacing=8:enable='between(t,0,${config.hook.duration_seconds})'[outv]`
        ].join(';');

        // Arguments FFmpeg
        const ffmpegArgs = [
            '-y',
            '-i', videoInputPath,
            '-filter_complex', filterComplex,
            '-map', '[outv]',
            '-map', '0:a?',
            '-c:v', 'libx264',
            '-preset', 'veryfast',
            '-crf', '23',
            '-r', config.video.fps.toString(),
            '-b:v', config.video.bitrate,
            '-c:a', 'aac',
            '-b:a', '128k',
            outputPath
        ];

        const startTime = Date.now();
        const ffmpeg = spawn('ffmpeg', ffmpegArgs);

        let lastProgress = '';

        ffmpeg.stderr.on('data', (data) => {
            const str = data.toString();
            // Extraire le temps encod√©
            const timeMatch = str.match(/time=(\d{2}:\d{2}:\d{2})/);
            if (timeMatch && timeMatch[1] !== lastProgress) {
                lastProgress = timeMatch[1];
                process.stdout.write(`\r         Encodage: ${lastProgress}`);
            }
        });

        ffmpeg.on('close', (code) => {
            const duration = ((Date.now() - startTime) / 1000).toFixed(1);
            console.log(''); // Nouvelle ligne

            if (code === 0 && fs.existsSync(outputPath)) {
                const stats = fs.statSync(outputPath);
                const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);

                log("EXPORT", "SUCCESS", `${outputFilename} (${sizeMB} MB, ${duration}s)`);

                resolve({
                    input: clip.original_filename,
                    output: outputFilename,
                    outputPath,
                    hook: clip.hook,
                    sizeMB: parseFloat(sizeMB),
                    encodingTime: parseFloat(duration)
                });
            } else {
                log("EXPORT", "FAILED", `Erreur FFmpeg code ${code}`, outputFilename);
                resolve(null);
            }
        });

        ffmpeg.on('error', (err) => {
            log("EXPORT", "FAILED", err.message, outputFilename);
            resolve(null);
        });
    });
}

// ============ MAIN ============
async function run() {
    console.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
    console.log(`‚ïë  CHLOE - Production TikTok v${config.version}     ‚ïë`);
    console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n`);

    log("INITIALIZATION", "OK", "Agent CHLOE pr√™te");

    // Chercher la s√©lection de MARC
    const selectionFiles = fs.readdirSync(INPUT_DIR).filter(f => f.startsWith('selection_'));

    if (selectionFiles.length === 0) {
        log("SCAN", "FAILED", "Aucune s√©lection MARC trouv√©e", "Attente ordre de production");
        return;
    }

    const latestSelection = selectionFiles.sort().reverse()[0];
    log("SCAN", "OK", `S√©lection trouv√©e: ${latestSelection}`);

    const selection = JSON.parse(fs.readFileSync(path.join(INPUT_DIR, latestSelection), 'utf8'));

    log("READ", "OK", `Session: ${selection.session_id}, ${selection.clips_selected} clips √† produire`);
    console.log(`         Strat√©gie: ${selection.selection_method}\n`);

    // Produire chaque clip
    const results = [];

    for (let i = 0; i < selection.clips.length; i++) {
        const clip = selection.clips[i];

        console.log(`\n[CHLOE] üìπ Clip ${i + 1}/${selection.clips.length}`);

        // Trouver le fichier vid√©o source
        const videoInputPath = path.join(INPUT_DIR, clip.original_filename);

        if (!fs.existsSync(videoInputPath)) {
            log("SCAN", "FAILED", `Fichier source introuvable: ${clip.original_filename}`);
            continue;
        }

        const result = await produceVideo(clip, videoInputPath);
        if (result) {
            results.push(result);
        }
    }

    // R√©sum√© final
    console.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
    console.log(`‚ïë  R√©sultat                              ‚ïë`);
    console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n`);

    console.log(`[CHLOE] üì¶ ${results.length}/${selection.clips.length} vid√©os produites\n`);

    results.forEach((r, i) => {
        console.log(`       ${i + 1}. ${r.output}`);
        console.log(`          Hook: "${r.hook}"`);
        console.log(`          Taille: ${r.sizeMB} MB`);
    });

    log("FINALIZATION", "SUCCESS", `${results.length} vid√©os TikTok produites`, "Pr√™t pour LEA");

    console.log(`\n[CHLOE] ‚úÖ Termin√©. Vid√©os envoy√©es √† LEA pour validation.\n`);
}

run().catch(e => {
    log("ERROR", "FAILED", e.message);
    process.exit(1);
});
