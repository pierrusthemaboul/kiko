// ============= kiko-info/constants/colors.ts =============
export const colors = {
    // Couleurs primaires
    primary: '#1D5F9E',      // Bleu principal
    secondary: '#0A173D',    // Navy Blue profond
    accent: '#FFCC00',       // Or métallique
  
    // Couleurs sémantiques
    correctGreen: '#27ae60',   // Pour les bonnes réponses
    incorrectRed: '#e74c3c',   // Pour les mauvaises réponses
    warningYellow: '#f1c40f',  // Pour les alertes/avertissements
    timerNormal: '#4ECDC4',    // Pour le timer en état normal
  
    // Couleurs de texte
    text: '#2c3e50',           // Texte principal
    lightText: '#7f8c8d',      // Texte secondaire
    darkText: '#2c3e50',       // Texte foncé
    white: '#FFFFFF',          // Blanc pur
  
    // Couleurs de fond
    background: {
      dark: '#020817',         // Fond très sombre
      medium: '#050B1F',       // Fond sombre
      light: '#0A173D'         // Fond moins sombre
    },
  
    // Couleurs de transparence
    transparencies: {
      light: 'rgba(255, 255, 255, 0.1)',
      medium: 'rgba(255, 255, 255, 0.3)',
      dark: 'rgba(0, 0, 0, 0.5)'
    },
  
    // Couleurs de cardBackground
    cardBackground: '#FFFFFF',   // Fond des cartes
  
    // Gradients (pour référence)
    gradients: {
      primary: ['#1D5F9E', '#0A173D'],     // Gradient principal
      secondary: ['#FFBF00', '#CC9900'],    // Gradient secondaire
      tertiary: ['#0A173D', '#1D5F9E']      // Gradient tertiaire
    }
  } as const;
  
  export default colors;


// ============= kiko-info/constants/Colors.ts =============
export const Colors = {
    light: {
      text: '#000000',
      background: '#FFFFFF',
      primary: '#1D5F9E',
      secondary: '#0A173D',
      tint: '#2f95dc',
      tabIconDefault: '#cccccc',
      tabIconSelected: '#2f95dc',
      border: '#cccccc',
    },
    dark: {
      text: '#FFFFFF',
      background: '#020817',
      primary: '#1D5F9E',
      secondary: '#0A173D',
      tint: '#ffffff',
      tabIconDefault: '#cccccc',
      tabIconSelected: '#ffffff',
      border: '#272729',
    },
  } as const;
  
  export type ColorTheme = typeof Colors.light & typeof Colors.dark;
  
  export default Colors;


// ============= kiko-info/hooks/useAudio.ts =============
// 1. Configuration Audio
// ==================
// 1.A. Imports et Types
// -------------------
import { useState, useCallback, useEffect, useRef } from 'react';
import { Audio } from 'expo-av';
// No longer using gameLogger, using console directly

// 1.B. Interfaces
// -------------
interface CachedSound {
  sound: Audio.Sound;
  status: Audio.PlaybackStatus;
  lastPlayed?: number;
}

// 2. Hook Principal
// ===============
export const useAudio = () => {
  // 2.A. États
  // ---------
  // 2.A.a. États des sons
  const [sounds, setSounds] = useState<{ [key: string]: CachedSound | null }>({
    correct: null,
    incorrect: null,
    levelUp: null,
    countdown: null,
    gameover: null,
  });

  // 2.A.b. États de contrôle
  const soundVolumeRef = useRef(0.80);
  const musicVolumeRef = useRef(0.80);
  const [soundVolume, setSoundVolume] = useState(0.80);
  const [musicVolume, setMusicVolume] = useState(0.80);
  const [isSoundEnabled, setIsSoundEnabled] = useState(true);
  const [isMusicEnabled, setIsMusicEnabled] = useState(true);
  const isInitialized = useRef(false);

  // 2.B. Configuration
  // ----------------
// 2.B.a. Chemins des sons
const soundPaths = {
    correct: require('../assets/sounds/corectok.wav'),
    incorrect: require('../assets/sounds/361260__japanyoshithegamer__8-bit-wrong-sound.wav'),
    levelUp: require('../assets/sounds/423455__ohforheavensake__trumpet-brass-fanfare.wav'),
    countdown: require('../assets/sounds/361254__japanyoshithegamer__8-bit-countdown-ready.wav'),
    gameover: require('../assets/sounds/242208__wagna__failfare.mp3')
  };

  // 3. Initialisation
  // ===============
  // 3.A. Configuration Initiale
  // -------------------------
  useEffect(() => {
    const initAudio = async () => {
      try {
        // 3.A.a. Configuration système
        const audioConfig = {
          allowsRecordingIOS: false,
          staysActiveInBackground: true,
          playsInSilentModeIOS: true,
          shouldDuckAndroid: true,
          playThroughEarpieceAndroid: false
        };

        await Audio.setAudioModeAsync(audioConfig);

        // 3.A.b. Chargement initial des sons
        for (const [key, path] of Object.entries(soundPaths)) {
          await loadSound(key);
        }

        isInitialized.current = true;
      } catch (error) {
        // Handle initialization error if needed
      }
    };

    initAudio();

    // 3.B. Nettoyage
    // -------------
    return () => {
      isInitialized.current = false;
      Object.entries(sounds).forEach(async ([_, soundObj]) => {
        if (soundObj?.sound) {
          try {
            await soundObj.sound.unloadAsync();
          } catch (error) {
            // Handle unloading error if needed
          }
        }
      });
    };
  }, []);

  // 4. Gestion des Sons
  // =================
  // 4.A. Chargement des Sons
  // ----------------------
  const loadSound = async (soundKey: string): Promise<Audio.Sound | null> => {
    try {
      if (!sounds[soundKey]) {
        const { sound, status } = await Audio.Sound.createAsync(
          soundPaths[soundKey],
          { 
            volume: soundVolumeRef.current * 0.1,
            shouldPlay: false,
            progressUpdateIntervalMillis: 50
          }
        );

        sound.setOnPlaybackStatusUpdate(status => {
          if (!status.isLoaded) {
            reloadSound(soundKey);
          }
          if (status.didJustFinish) {
            // Handle sound finish if needed
          }
        });

        setSounds(prev => ({
          ...prev,
          [soundKey]: { 
            sound, 
            status,
            lastPlayed: Date.now()
          }
        }));

        return sound;
      }
      return sounds[soundKey]?.sound || null;
    } catch (error) {
      return null;
    }
  };

  // 4.B. Rechargement des Sons
  // ------------------------
  const reloadSound = async (soundKey: string) => {
    try {
      if (sounds[soundKey]?.sound) {
        await sounds[soundKey]?.sound.unloadAsync();
      }
      await loadSound(soundKey);
    } catch (error) {
      // Handle reloading error if needed
    }
  };

  // 4.C. Lecture des Sons
  // -------------------
  const playSound = async (soundKey: string, volume: number = soundVolumeRef.current) => {
    if (!isSoundEnabled || !isInitialized.current) return;

    try {
      // 1. Décharger l'ancien son s'il existe
      if (sounds[soundKey]?.sound) {
        try {
          await sounds[soundKey].sound.unloadAsync();
        } catch (err) {
          // Handle unloading error if needed
        }
      }

      // 2. Créer une nouvelle instance du son
      const { sound, status } = await Audio.Sound.createAsync(
        soundPaths[soundKey],
        { volume: volume * 0.5, shouldPlay: false }
      );

      // 3. Mettre à jour l'état avec le nouveau son
      setSounds(prev => ({
        ...prev,
        [soundKey]: { sound, status, lastPlayed: Date.now() }
      }));

      // 4. Jouer le son
      await sound.setVolumeAsync(Math.min(volume * 0.5, 0.5));
      await sound.playAsync();

      // 5. Configuration du nettoyage après lecture
      sound.setOnPlaybackStatusUpdate(status => {
        if (status.didJustFinish) {
          sound.unloadAsync().catch(err => {
            // Handle unloading error if needed
          });
        }
      });

    } catch (error) {
      const soundToClean = sounds[soundKey]?.sound;
      if (soundToClean) {
        try {
          await soundToClean.unloadAsync();
        } catch (err) {
          // Handle unloading error if needed
        }
      }
    }
  };

  // 5. Fonctions de Lecture Spécifiques
  // =================================
  // 5.A. Sons du Jeu
  // --------------
  const playCorrectSound = useCallback(() => {
    return playSound('correct', soundVolumeRef.current * 0.2);
  }, [isSoundEnabled]);

  const playIncorrectSound = useCallback(() => {
    return playSound('incorrect', soundVolumeRef.current * 0.15);
  }, [isSoundEnabled]);

  const playLevelUpSound = useCallback(() => {
    return playSound('levelUp', soundVolumeRef.current * 0.1);
  }, [isSoundEnabled]);

  const playCountdownSound = useCallback(() => {
    return playSound('countdown', soundVolumeRef.current * 0.1);
  }, [isSoundEnabled]);

  const playGameOverSound = useCallback(() => {
    return playSound('gameover', soundVolumeRef.current * 0.15);
  }, [isSoundEnabled]);

  // 6. Contrôles Audio
  // ================
  // 6.A. Gestion du Volume
  // -------------------
  const setVolume = async (volume: number, type: 'sound' | 'music') => {
    try {
      const safeVolume = Math.min(volume, 0.1);
      if (type === 'sound') {
        soundVolumeRef.current = safeVolume;
        setSoundVolume(safeVolume);
        await Promise.all(
          Object.entries(sounds).map(async ([_, soundObj]) => {
            if (soundObj?.sound) {
              try {
                await soundObj.sound.setVolumeAsync(safeVolume);
              } catch (error) {
                // Handle setting volume error if needed
              }
            }
          })
        );
      } else {
        musicVolumeRef.current = safeVolume;
        setMusicVolume(safeVolume);
      }
    } catch (error) {
      // Handle setting volume error if needed
    }
  };

  // 6.B. Contrôles de l'Audio
  // -----------------------
  const toggleSound = (enabled: boolean) => {
    setIsSoundEnabled(enabled);
  };

  const toggleMusic = (enabled: boolean) => {
    setIsMusicEnabled(enabled);
  };

  // 7. Interface Publique
  // ===================
  return {
    playCorrectSound,
    playIncorrectSound,
    playLevelUpSound,
    playCountdownSound,
    playGameOverSound,
    setSoundVolume: (volume: number) => setVolume(volume, 'sound'),
    setMusicVolume: (volume: number) => setVolume(volume, 'music'),
    toggleSound,
    toggleMusic,
    isSoundEnabled,
    isMusicEnabled,
    soundVolume,
    musicVolume
  };
};

export default useAudio;



// ============= kiko-info/hooks/useAdminStatus.ts =============
import { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase/supabaseClients';

export default function useAdminStatus() {
  const [isAdmin, setIsAdmin] = useState(false);

  useEffect(() => {
    checkAdminStatus();
  }, []);

  const checkAdminStatus = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        const { data, error } = await supabase
          .from('profiles')
          .select('is_admin')
          .eq('id', user.id)
          .single();

        if (data) {
          setIsAdmin(data.is_admin);
        }
      }
    } catch (error) {
      console.error('Erreur lors de la vérification du statut admin:', error);
    }
  };

  return { isAdmin };
}


// ============= kiko-info/hooks/levelConfigs.ts =============
import { LevelConfig, SpecialRules } from "./types";

export const LEVEL_CONFIGS: Record<number, LevelConfig> = {
  1: {
    level: 1,
    name: "Novice",
    description: "Premiers pas dans l'histoire",
    eventsNeeded: 5,
    timeGap: {
      base: 500,
      variance: 200,
      minimum: 300,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 1,
      universalOnly: true,
      specialEventChance: 0,
    },
    scoring: {
      basePoints: 100,
      streakMultiplier: 1.0,
      timeMultiplier: 1.0,
      comboThreshold: 2,
    },
    specialRules: [],
    pointsReward: 100,
  },
  2: {
    level: 2,
    name: "Explorateur",
    description: "Découverte des événements faciles",
    eventsNeeded: 6,
    timeGap: {
      base: 450,
      variance: 200,
      minimum: 250,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 1,
      universalOnly: false,
      specialEventChance: 0.05,
    },
    scoring: {
      basePoints: 110,
      streakMultiplier: 1.1,
      timeMultiplier: 1.05,
      comboThreshold: 2,
    },
    specialRules: [],
    pointsReward: 150,
  },
  3: {
    level: 3,
    name: "Initié",
    description: "Introduction aux événements moyens",
    eventsNeeded: 7,
    timeGap: {
      base: 400,
      variance: 150,
      minimum: 200,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 2,
      universalOnly: false,
      specialEventChance: 0.1,
    },
    scoring: {
      basePoints: 120,
      streakMultiplier: 1.2,
      timeMultiplier: 1.1,
      comboThreshold: 3,
    },
    specialRules: [],
    pointsReward: 200,
  },
  4: {
    level: 4,
    name: "Voyageur Temporel",
    description: "Événements faciles et moyens mélangés",
    eventsNeeded: 8,
    timeGap: {
      base: 350,
      variance: 150,
      minimum: 150,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 2,
      universalOnly: false,
      specialEventChance: 0.15,
    },
    scoring: {
      basePoints: 130,
      streakMultiplier: 1.2,
      timeMultiplier: 1.15,
      comboThreshold: 3,
    },
    specialRules: [],
    pointsReward: 250,
  },
  5: {
    level: 5,
    name: "Chroniqueur",
    description: "Principalement des événements moyens",
    eventsNeeded: 9,
    timeGap: {
      base: 300,
      variance: 100,
      minimum: 100,
    },
    eventSelection: {
      minDifficulty: 2,
      maxDifficulty: 2,
      universalOnly: false,
      specialEventChance: 0.2,
    },
    scoring: {
      basePoints: 140,
      streakMultiplier: 1.3,
      timeMultiplier: 1.2,
      comboThreshold: 4,
    },
    specialRules: [],
    pointsReward: 300,
  },
  6: {
    level: 6,
    name: "Historien Amateur",
    description: "Introduction aux événements difficiles",
    eventsNeeded: 10,
    timeGap: {
      base: 250,
      variance: 100,
      minimum: 75,
    },
    eventSelection: {
      minDifficulty: 2,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.25,
    },
    scoring: {
      basePoints: 150,
      streakMultiplier: 1.4,
      timeMultiplier: 1.25,
      comboThreshold: 4,
    },
    specialRules: [],
    pointsReward: 350,
  },
  7: {
    level: 7,
    name: "Historien Éclairé",
    description: "Événements moyens et difficiles",
    eventsNeeded: 11,
    timeGap: {
      base: 200,
      variance: 75,
      minimum: 50,
    },
    eventSelection: {
      minDifficulty: 2,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.3,
    },
    scoring: {
      basePoints: 160,
      streakMultiplier: 1.5,
      timeMultiplier: 1.3,
      comboThreshold: 5,
    },
    specialRules: [],
    pointsReward: 400,
  },
  8: {
    level: 8,
    name: "Maître du Temps",
    description: "Tous types d'événements commencent à apparaître",
    eventsNeeded: 12,
    timeGap: {
      base: 150,
      variance: 75,
      minimum: 50,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.35,
    },
    scoring: {
      basePoints: 170,
      streakMultiplier: 1.6,
      timeMultiplier: 1.35,
      comboThreshold: 5,
    },
    specialRules: [],
    pointsReward: 450,
  },
  9: {
    level: 9,
    name: "Savant Historique",
    description: "Événements complexes à démêler",
    eventsNeeded: 13,
    timeGap: {
      base: 125,
      variance: 50,
      minimum: 40,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.4,
    },
    scoring: {
      basePoints: 180,
      streakMultiplier: 1.7,
      timeMultiplier: 1.4,
      comboThreshold: 6,
    },
    specialRules: [],
    pointsReward: 500,
  },
  10: {
    level: 10,
    name: "Expert Historien",
    description: "Principalement des événements difficiles",
    eventsNeeded: 14,
    timeGap: {
      base: 100,
      variance: 50,
      minimum: 30,
    },
    eventSelection: {
      minDifficulty: 3,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.45,
    },
    scoring: {
      basePoints: 190,
      streakMultiplier: 1.8,
      timeMultiplier: 1.45,
      comboThreshold: 6,
    },
    specialRules: [],
    pointsReward: 550,
  },
  11: {
    level: 11,
    name: "Grand Historien",
    description: "Un défi pour les érudits",
    eventsNeeded: 15,
    timeGap: {
      base: 80,
      variance: 40,
      minimum: 25,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.5,
    },
    scoring: {
      basePoints: 200,
      streakMultiplier: 1.9,
      timeMultiplier: 1.5,
      comboThreshold: 7,
    },
    specialRules: [],
    pointsReward: 600,
  },
  12: {
    level: 12,
    name: "Historien Légendaire",
    description: "Seuls les plus grands réussissent",
    eventsNeeded: 16,
    timeGap: {
      base: 60,
      variance: 30,
      minimum: 20,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.55,
    },
    scoring: {
      basePoints: 210,
      streakMultiplier: 2.0,
      timeMultiplier: 1.55,
      comboThreshold: 7,
    },
    specialRules: [],
    pointsReward: 650,
  },
  13: {
    level: 13,
    name: "Maître Historien",
    description: "Ultime épreuve de connaissance",
    eventsNeeded: 17,
    timeGap: {
      base: 40,
      variance: 20,
      minimum: 15,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.6,
    },
    scoring: {
      basePoints: 220,
      streakMultiplier: 2.1,
      timeMultiplier: 1.6,
      comboThreshold: 8,
    },
    specialRules: [],
    pointsReward: 700,
  },
  14: {
    level: 14,
    name: "Oracle du Temps",
    description: "Seul le temps nous le dira",
    eventsNeeded: 18,
    timeGap: {
      base: 20,
      variance: 10,
      minimum: 10,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.65,
    },
    scoring: {
      basePoints: 230,
      streakMultiplier: 2.2,
      timeMultiplier: 1.65,
      comboThreshold: 8,
    },
    specialRules: [],
    pointsReward: 750,
  },
  15: {
    level: 15,
    name: "Dieu",
    description: "Le boss final",
    eventsNeeded: 10000,
    timeGap: {
      base: 1,
      variance: 1,
      minimum: 1,
    },
    eventSelection: {
      minDifficulty: 1,
      maxDifficulty: 3,
      universalOnly: false,
      specialEventChance: 0.7,
    },
    scoring: {
      basePoints: 1000,
      streakMultiplier: 2.3,
      timeMultiplier: 1.7,
      comboThreshold: 9,
    },
    specialRules: [],
    pointsReward: 1000,
  },
};

export default LEVEL_CONFIGS;



// ============= kiko-info/hooks/useGameLogicA.ts =============
// -----------------------------------------------------------------------------
// ON arrive trop souvent avant l'n 500. C'est à cause des sauts. Tu crois que 
// sans affecter la performance de l'appli on pourrait :
// Comprendre les périodes dans lesquelles les joueurs ont été et adapter 
// les sauts en fonction ?
/************************************************************************************
 * 1. HOOK PRINCIPAL : useGameLogicA
 *
 * 1.A. Description
 *     Hook de logique de jeu principal. Gère la logique de sélection d'événements,
 *     le scoring, la gestion du niveau, l'audio, les récompenses et la fin de partie.
 *
 * 1.B. Paramètres
 *     @param {string} initialEvent - Identifiant éventuel d'un événement initial.
 *
 * 1.C. Retour
 *     {object} - Ensemble d'états et de fonctions utiles au jeu (user, événements, etc.).
 ************************************************************************************/

/* 1.D. Imports et Types */

// 1.D.1. Librairies / Modules
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '../lib/supabase/supabaseClients';
import useRewards from './useRewards';
import useAudio from './useAudio';
import {
  Event,
  User,
  ExtendedLevelConfig,
  RewardType,
  MAX_LIVES,
  HistoricalPeriod,
  LevelEventSummary,
  CategoryMastery,
  HistoricalPeriodStats,
  LevelPerformance,
  ActiveBonus
} from './types';
import { LEVEL_CONFIGS } from './levelConfigs';
import { Animated } from 'react-native';

/* 1.E. Hook : useGameLogicA */

/**
 * Hook de logique de jeu (quiz historique).
 * @function useGameLogicA
 * @param {string} initialEvent - Optionnel, événement de départ.
 * @returns {Object} - Toutes les données et fonctions nécessaires au jeu.
 */
export function useGameLogicA(initialEvent: string) {

  /* 1.E.1. (Récompenses - système) */
  const {
    currentReward,
    checkRewards,
    completeRewardAnimation,
    updateRewardPosition
  } = useRewards({
    onRewardEarned: (reward) => {
      applyReward(reward);
    },
  });

  /* 1.E.2. (Audio - sons) */
  const {
    playCorrectSound,
    playIncorrectSound,
    playLevelUpSound,
    playCountdownSound,
    playGameOverSound,
  } = useAudio();

  /* 1.E.3. (Profil utilisateur de base) */
  const [user, setUser] = useState<User>({
    name: '',
    points: 0,
    lives: MAX_LIVES,
    level: 1,
    eventsCompletedInLevel: 0,
    totalEventsCompleted: 0,
    streak: 0,
    maxStreak: 0,
    performanceStats: {
      typeSuccess: {},
      periodSuccess: {},
      overallAccuracy: 0,
      averageResponseTime: 0
    }
  });

  /* 1.E.4. (États du jeu) */
  const [activeBonus, setActiveBonus] = useState<ActiveBonus[]>([]);
  const [periodStats, setPeriodStats] = useState<Record<HistoricalPeriod, HistoricalPeriodStats>>({});
  const [categoryMastery, setCategoryMastery] = useState<Record<string, CategoryMastery>>({});
  const [eventHistory, setEventHistory] = useState<{ type: string; period: string; success: boolean; }[]>([]);
  const [performanceStats, setPerformanceStats] = useState<{
    typeSuccess: Record<string, number>;
    periodSuccess: Record<string, number>;
    overallAccuracy: number;
  }>({
    typeSuccess: {},
    periodSuccess: {},
    overallAccuracy: 0
  });

  /* 1.E.5. (Événements) */
  const [allEvents, setAllEvents] = useState<Event[]>([]);
  const [previousEvent, setPreviousEvent] = useState<Event | null>(null);
  const [newEvent, setNewEvent] = useState<Event | null>(null);
  const [usedEvents, setUsedEvents] = useState<Set<string>>(new Set());

  /* 1.E.6. (Interface utilisateur) */
  const [timeLeft, setTimeLeft] = useState(20);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isGameOver, setIsGameOver] = useState(false);

  /* 1.E.7. (Chargement d’image) */
  const [isImageLoaded, setIsImageLoaded] = useState(false);

  /* 1.E.8. (Affichage de dates, correctitude) */
  const [showDates, setShowDates] = useState(false);
  const [isCorrect, setIsCorrect] = useState<boolean | undefined>(undefined);

  /* 1.E.9. (Progression) */
  const [streak, setStreak] = useState(0);
  const [highScore, setHighScore] = useState(0);

  /* 1.E.10. (Contrôle du jeu) */
  const [isCountdownActive, setIsCountdownActive] = useState(false);
  const [showLevelModal, setShowLevelModal] = useState(false);
  const [isLevelPaused, setIsLevelPaused] = useState(true);
  const [currentLevelConfig, setCurrentLevelConfig] = useState<ExtendedLevelConfig>({
    ...LEVEL_CONFIGS[1], // Initialisation avec la config du niveau 1
    eventsSummary: []     // Initialisation de eventsSummary comme un tableau vide
  });
  const [leaderboardsReady, setLeaderboardsReady] = useState(false);
  const [isWaitingForCountdown, setIsWaitingForCountdown] = useState(false);

  /* 1.E.11. (Classement) */
  const [leaderboards, setLeaderboards] = useState({ daily: [], monthly: [], allTime: [] });

  /* 1.E.12. (Événements de niveau) */
  const [currentLevelEvents, setCurrentLevelEvents] = useState<LevelEventSummary[]>([]);

  /* 1.E.13. (Fallback countdown) */
  const [fallbackCountdown, setFallbackCountdown] = useState<number>(() => {
    return Math.floor(Math.random() * (25 - 12 + 1)) + 12;
  });

  /* 1.E.14. (Animation - streak bar) */
  const [progressAnim] = useState(() => new Animated.Value(0));

  const [levelCompletedEvents, setLevelCompletedEvents] = useState<LevelEventSummary[]>([]);

  const [forcedJumpEventCount, setForcedJumpEventCount] = useState<number>(() => {
    return Math.floor(Math.random() * (19 - 12 + 1)) + 12;
  });

  const [eventCount, setEventCount] = useState<number>(0);

  const [hasInitialJumped, setHasInitialJumped] = useState<boolean>(false);

  const [hasFirstForcedJumpHappened, setHasFirstForcedJumpHappened] = useState<boolean>(false);

  const [initialJumpDistance, setInitialJumpDistance] = useState<number>(() => {
    const distances = [500, 750, 1000];
    return distances[Math.floor(Math.random() * distances.length)];
  });

  const [initialJumpEventCount, setInitialJumpEventCount] = useState<number>(() => {
    return Math.floor(Math.random() * (19 - 12 + 1)) + 12;
  });


  /* 1.F. Effet d'initialisation */
  useEffect(() => {
    initGame();
  }, []);

  // 1.G. Compte à rebours
  useEffect(() => {
    let timer: NodeJS.Timeout | undefined;

    if (isCountdownActive && timeLeft > 0 && !isLevelPaused && !isGameOver) {
      timer = setInterval(() => {
        setTimeLeft((prevTime) => {
          if (prevTime <= 1) {
            handleTimeout();
            return 0;
          }
          if (prevTime <= 5) {
            playCountdownSound();
          }
          return prevTime - 1;
        });
      }, 1000);
    }

    return () => {
      if (timer) clearInterval(timer);
    };
  }, [isCountdownActive, isLevelPaused, isGameOver, timeLeft]); // Dépendances optimisées

  /* 1.H. Regroupement des fonctions internes */

  // 1.H.1. initGame
  /**
   * 1.H.1. Initialisation du jeu (fetch user, config niveau 1, etc.)
   * @async
   * @function initGame
   * @returns {void}
   */
  const initGame = async () => {
    try {
      setLoading(true);
      await fetchUserData();

      const initialConfig = LEVEL_CONFIGS[1];
      if (!initialConfig) {
        throw new Error('Configuration du niveau 1 manquante');
      }
      setCurrentLevelConfig(initialConfig);

      const { data: events, error: eventsError } = await supabase
        .from('evenements')
        .select('*')
        .order('date', { ascending: true });

      if (eventsError) throw eventsError;
      if (!events?.length) {
        throw new Error('Aucun événement disponible');
      }

      const validEvents = events.filter(
        (event) =>
          event.date &&
          event.titre &&
          event.illustration_url &&
          event.niveau_difficulte &&
          event.types_evenement
      );
      setAllEvents(validEvents);

      if (validEvents.length < 2) {
        throw new Error("Pas assez d'événements disponibles");
      }

      // --- MODIFICATION ICI : Sélection des événements de niveau 1 uniquement ---
      const level1Events = validEvents.filter((e) => e.niveau_difficulte === 1);

      if (level1Events.length < 2) {
        throw new Error("Pas d'événements adaptés au niveau 1 disponibles");
      }
      // --- FIN DE LA MODIFICATION ---

      // Sélection du premier événement
      const firstIndex = Math.floor(Math.random() * level1Events.length);
      const firstEvent = level1Events[firstIndex];

      // Calcul de l'année de référence pour le 1er événement
      function yearFromDate(dateString: string): number {
        return new Date(dateString).getFullYear();
      }
      const referenceYear = yearFromDate(firstEvent.date);

      // On filtre les autres événements
      const filteredForSecond = level1Events.filter((e) => e.id !== firstEvent.id);

      // Filtrage pour avoir au moins 500 ans d'écart
      const validSecondEvents = filteredForSecond.filter(
        (e) => Math.abs(yearFromDate(e.date) - referenceYear) >= 500
      );

      if (validSecondEvents.length === 0) {
        throw new Error('Aucun second événement ne répond à l’écart minimal de 500 ans');
      }

      // Sélection du second événement dans ce sous-ensemble
      const secondIndex = Math.floor(Math.random() * validSecondEvents.length);
      const secondEvent = validSecondEvents[secondIndex];

      setPreviousEvent(firstEvent);
      setNewEvent(secondEvent);
      setUsedEvents(new Set([firstEvent.id, secondEvent.id]));

      setIsLevelPaused(false);
      setIsCountdownActive(true);
      setTimeLeft(20);

    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "Erreur d'initialisation";
      setError(errorMsg);
    } finally {
      setLoading(false);
    }
  };

  // 1.H.2. fetchUserData
  /**
   * 1.H.2. Récupération des données user (profils, high score)
   * @async
   * @function fetchUserData
   * @returns {void}
   */
  const fetchUserData = async () => {
    try {
      const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();
      if (authError) throw authError;

      if (authUser) {
        const { data, error } = await supabase
          .from('profiles')
          .select('display_name, high_score')
          .eq('id', authUser.id)
          .single();
        if (error) throw error;

        if (data) {
          setUser((prev) => ({
            ...prev,
            name: data.display_name
          }));
          setHighScore(data.high_score || 0);
        }
      }
    } catch (error) {
      // Gestion des erreurs si nécessaire
    }
  };

  // 1.H.3. handleImageLoad
  /**
   * 1.H.3. Gère la fin de chargement d'image pour activer le compte à rebours
   * @function handleImageLoad
   * @returns {void}
   */
  const handleImageLoad = () => {
    setIsImageLoaded(true);
    if (!isLevelPaused) {
      setIsCountdownActive(true);
    }
  };

  // 1.H.4. Fonctions updateGameState et selectNewEvent

  // 1.H.4.a. getTimeDifference
  /**
   * 1.H.4.a. Calcule la différence en années entre deux dates (approx.)
   * @function getTimeDifference
   * @param {string} date1
   * @param {string} date2
   * @returns {number} - Différence en années
   */
  const getTimeDifference = useCallback((date1: string, date2: string) => {
    try {
      const d1 = new Date(date1).getTime();
      const d2 = new Date(date2).getTime();
      const diffInYears = Math.abs(d1 - d2) / (365.25 * 24 * 60 * 60 * 1000);
      return diffInYears;
    } catch (error) {
      return Infinity;
    }
  }, []);

  // 1.H.4.b. getPeriod
  /**
   * 1.H.4.b. Détermine la période historique à partir d’une date
   * @function getPeriod
   * @param {string} date
   * @returns {HistoricalPeriod}
   */
  const getPeriod = useCallback((date: string): HistoricalPeriod => {
    try {
      const year = new Date(date).getFullYear();
      if (year < 500) return HistoricalPeriod.ANTIQUITY;
      if (year < 1500) return HistoricalPeriod.MIDDLE_AGES;
      if (year < 1800) return HistoricalPeriod.RENAISSANCE;
      if (year < 1900) return HistoricalPeriod.NINETEENTH;
      if (year < 2000) return HistoricalPeriod.TWENTIETH;
      return HistoricalPeriod.TWENTYFIRST;
    } catch {
      return HistoricalPeriod.TWENTIETH;
    }
  }, []);

  // 1.H.4.c. updateGameState
  /**
   * 1.H.4.c. Met à jour l’état du jeu après sélection d’un événement
   * @async
   * @function updateGameState
   * @param {Event} selectedEvent
   * @returns {Promise<void>}
   */
  const updateGameState = useCallback(async (selectedEvent: Event) => {
    try {
      setUsedEvents((prev) => new Set([...prev, selectedEvent.id]));
      setNewEvent(selectedEvent);
      setIsImageLoaded(false);
      setShowDates(false);
      setIsCorrect(undefined);

      setIsCountdownActive(false);

      setTimeLeft(20);

      const period = getPeriod(selectedEvent.date);
      setEventHistory((prev) => [
        ...prev,
        {
          type: selectedEvent.types_evenement[0],
          period,
          success: false
        }
      ]);

    } catch (err) {
      // Gestion des erreurs si nécessaire
    }
  }, [getPeriod]);

  // 1.H.4.d.0 getNextForcedJumpIncrement
  /**
   * 1.H.4.d.0 Détermine l'intervalle du prochain saut forcé en fonction de l'année d'atterrissage
   * @function getNextForcedJumpIncrement
   * @param {number} year - Année d'atterrissage
   * @returns {number} - Incrément (nombre d'événements) avant le prochain saut forcé
   */
  function getNextForcedJumpIncrement(year: number): number {
    if (year < 500) {
      // Période < 500 => +[1..5]
      return Math.floor(Math.random() * (5 - 1 + 1)) + 1; 
    } else if (year >= 500 && year < 700) {
      // Période 500..699 => +[6..9]
      return Math.floor(Math.random() * (9 - 6 + 1)) + 6;
    } else if (year >= 700 && year < 1000) {
      // Période 700..999 => +[6..9]
      return Math.floor(Math.random() * (9 - 6 + 1)) + 6;
    } else if (year >= 1000 && year < 1500) {
      // Période 1000..1499 => +[6..9]
      return Math.floor(Math.random() * (9 - 6 + 1)) + 6;
    } else if (year >= 1500 && year < 1800) {
      // Période 1500..1799 => +[7..11]
      return Math.floor(Math.random() * (11 - 7 + 1)) + 7;
    } else if (year >= 1800 && year <= 2024) {
      // Période 1800..2024 => +[12..19]
      return Math.floor(Math.random() * (19 - 12 + 1)) + 12;
    } else {
      // Au-delà de 2024 => Incrément arbitraire
      return 15;
    }
  }

  // 1.H.4.d. selectNewEvent
  /**
   * 1.H.4.d. Sélectionne un nouvel événement en se basant sur la configuration de niveau
   * et gère la logique des sauts forcés.
   *
   * @async
   * @function selectNewEvent
   * @param {Event[]} events - Liste complète d'événements disponibles
   * @param {Event} referenceEvent - Événement de référence pour calculer la période/année
   * @returns {Promise<Event|null>} - L'événement sélectionné ou null si aucun événement n'est disponible
   */
  const selectNewEvent = useCallback(
    async (events: Event[], referenceEvent: Event) => {
      // 1) Vérifications initiales
      if (!events || events.length === 0) {
        return null;
      }

      // 2) Incrémentation du compteur d'événements joués
      setEventCount((prev) => prev + 1);
      const localEventCount = eventCount + 1; // Valeur mise à jour

      // 3) Année de référence
      const referenceYear = new Date(referenceEvent.date).getFullYear();

      // 4) checkTimeJump : détermine s'il y a un saut forcé ou conditionnel
      const checkTimeJump = (): number => {
        let jumpDistance = 0;

        // A) Saut forcé strict (si localEventCount == forcedJumpEventCount)
        if (localEventCount === forcedJumpEventCount) {
          const forcedDistances = [500, 750, 1000];
          jumpDistance =
            forcedDistances[Math.floor(Math.random() * forcedDistances.length)];
        }

        // B) Sauts conditionnels selon la période (limités à 1000 ans max)
        if (referenceYear < 500) {
          if (localEventCount >= 1 && localEventCount <= 5) {
            const arr = [750, 1000];
            const chosen = arr[Math.floor(Math.random() * arr.length)];
            jumpDistance = Math.max(jumpDistance, chosen);
          }
        } else if (referenceYear >= 500 && referenceYear < 1000) {
          if (localEventCount >= 7 && localEventCount <= 12) {
            const arr = [500, 1000];
            const chosen = arr[Math.random() < 0.5 ? 0 : 1];
            jumpDistance = Math.max(jumpDistance, chosen);
          }
        } else if (referenceYear >= 1000 && referenceYear < 1800) {
          if (localEventCount >= 7 && localEventCount <= 12) {
            const arr = [400, 750];
            const chosen = arr[Math.random() < 0.5 ? 0 : 1];
            jumpDistance = Math.max(jumpDistance, chosen);
          }
        } else if (referenceYear >= 1800 && referenceYear <= 2024) {
          // Logique spéciale, possible saut forcé 12..19
          // Vous pouvez ajouter ici des conditions supplémentaires si nécessaire
        }

        return jumpDistance;
      };

      const timeJump = checkTimeJump();

      // 5) Si timeJump > 0 => on tente un “événement lointain”
      if (timeJump > 0) {
        const isForcedJump = localEventCount === forcedJumpEventCount;

        // Déterminer la direction du saut
        let mainDirection: "past" | "future" = "future";
        if (isForcedJump && !hasFirstForcedJumpHappened) {
          mainDirection = "past";
        }

        /**
         * Helpers pour récupérer des événements passés ou futurs
         */
        const getPastEvents = (dist: number): Event[] => {
          const targetYear = referenceYear - dist;
          return events.filter((evt) => {
            const y = new Date(evt.date).getFullYear();
            return y <= targetYear && !usedEvents.has(evt.id);
          });
        };
        const getFutureEvents = (dist: number): Event[] => {
          const targetYear = referenceYear + dist;
          return events.filter((evt) => {
            const y = new Date(evt.date).getFullYear();
            return y >= targetYear && !usedEvents.has(evt.id);
          });
        };

        // 5.1. On tente d'abord la direction principale
        let possibleEvents: Event[] =
          mainDirection === "past"
            ? getPastEvents(timeJump)
            : getFutureEvents(timeJump);

        // 5.2. Si rien dans ce sens, on tente l'autre sens
        if (possibleEvents.length === 0) {
          possibleEvents =
            mainDirection === "past"
              ? getFutureEvents(timeJump)
              : getPastEvents(timeJump);
          // Si des événements sont trouvés dans l'autre direction
          // Vous pouvez ajouter une logique supplémentaire ici si nécessaire
        }

        // 5.3. Sélection finale s'il existe des événements possibles
        if (possibleEvents.length > 0) {
          const chosen =
            possibleEvents[Math.floor(Math.random() * possibleEvents.length)];

          // Mise à jour du jeu
          await updateGameState(chosen);
          setIsCountdownActive(true);

          // Incrément de frequency_score en base
          await supabase
            .from("evenements")
            .update({
              frequency_score: (chosen as any).frequency_score + 1 || 1,
              last_used: new Date().toISOString(),
            })
            .eq("id", chosen.id);

          // 5.4. Gestion du recalcul du prochain saut forcé
          if (isForcedJump) {
            // Si c'était le tout premier saut forcé
            if (!hasFirstForcedJumpHappened) {
              setHasFirstForcedJumpHappened(true);
            }

            // Déterminer la période d'atterrissage de l'événement choisi
            const landingYear = new Date(chosen.date).getFullYear();

            // Calculer l'incrément du prochain saut forcé selon la période d'atterrissage
            let nextIncrement = 0;
            if (landingYear < 500) {
              // Sauts forcés suivants => +[1..5]
              nextIncrement = Math.floor(Math.random() * (5 - 1 + 1)) + 1;
            } else if (landingYear >= 500 && landingYear < 700) {
              // +[6..9]
              nextIncrement = Math.floor(Math.random() * (9 - 6 + 1)) + 6;
            } else if (landingYear >= 700 && landingYear < 1000) {
              // +[6..9]
              nextIncrement = Math.floor(Math.random() * (9 - 6 + 1)) + 6;
            } else if (landingYear >= 1000 && landingYear < 1500) {
              // +[6..9]
              nextIncrement = Math.floor(Math.random() * (9 - 6 + 1)) + 6;
            } else if (landingYear >= 1500 && landingYear < 1800) {
              // +[7..11]
              nextIncrement = Math.floor(Math.random() * (11 - 7 + 1)) + 7;
            } else if (landingYear >= 1800 && landingYear <= 2024) {
              // +[12..19]
              nextIncrement = Math.floor(Math.random() * (19 - 12 + 1)) + 12;
            } else {
              // Au-delà de 2024 => à adapter selon vos besoins
              nextIncrement = 15; // arbitraire
            }

            // Mise à jour de forcedJumpEventCount
            const newForcedCount = localEventCount + nextIncrement;
            setForcedJumpEventCount(newForcedCount);
          }

          // On retourne l'événement spécial sélectionné
          return chosen;
        }

        // Si aucun événement n'est trouvé, on poursuit en logique normale
      } // fin if (timeJump > 0)

      // 6) Logique normale (pas de saut forcé ou échec de recherche d'événements lointains)
      const config = LEVEL_CONFIGS[user.level];
      if (!config) {
        return null;
      }

      /**
       * Calcule l'écart de temps dynamique (min / base / max) en fonction 
       * de la distance à l'année actuelle
       */
      const calculateDynamicTimeGap = (referenceDate: string) => {
        const nowY = new Date().getFullYear();
        const refY = new Date(referenceDate).getFullYear();
        const yearsFromPresent = nowY - refY;
        // proportionnel : plus on est loin de l'époque moderne, plus on élargit les gaps
        const proximityFactor = Math.max(0.2, Math.min(1, yearsFromPresent / 500));

        const baseGap = config.timeGap.base * proximityFactor;
        const minGap = config.timeGap.minimum * proximityFactor;
        const maxGap = config.timeGap.base * proximityFactor * 1.5;

        return { base: baseGap, min: minGap, max: maxGap };
      };

      const timeGap = calculateDynamicTimeGap(referenceEvent.date);

      /**
       * scoreEvent : calcule un score pour un événement donné
       */
      const scoreEvent = (evt: Event, diff: number): number => {
        const randomFactor = 0.85 + Math.random() * 0.3;
        const idealGap = timeGap.base;

        // Score basé sur l'écart par rapport à l'idealGap
        const gapScore =
          35 * (1 - Math.abs(diff - idealGap) / idealGap) * randomFactor;

        // Score basé sur la difficulté (cible : difficulté ~2)
        const idealDifficulty = 2;
        const difficultyScore =
          25 *
          (1 - Math.abs(evt.niveau_difficulte - idealDifficulty) / 2) *
          randomFactor;

        // Petit bonus aléatoire
        const variationBonus = Math.random() * 10;

        return gapScore + difficultyScore + variationBonus;
      };

      // 6.1. Filtrage des événements non utilisés
      const availableEvents = events.filter((e) => !usedEvents.has(e.id));

      // 6.2. Score et tri
      const scoredEvents = availableEvents
        .map((e) => {
          const diff = getTimeDifference(e.date, referenceEvent.date);
          const s = scoreEvent(e, diff);
          return { event: e, timeDiff: diff, score: s };
        })
        .filter(
          ({ timeDiff }) => timeDiff >= timeGap.min && timeDiff <= timeGap.max
        )
        .sort((a, b) => b.score - a.score);

      // 6.3. Si aucun événement ne rentre dans la plage stricte => on fait une recherche relaxée
      if (scoredEvents.length === 0) {
        const relaxed = availableEvents
          .map((e) => {
            const diff = getTimeDifference(e.date, referenceEvent.date);
            const s = scoreEvent(e, diff);
            return { event: e, timeDiff: diff, score: s };
          })
          .filter(
            ({ timeDiff }) =>
              timeDiff >= timeGap.min * 0.5 && timeDiff <= timeGap.max * 2
          )
          .sort((a, b) => b.score - a.score);

        if (relaxed.length > 0) {
          const chosen = relaxed[0].event;

          await updateGameState(chosen);
          setIsCountdownActive(true);

          await supabase
            .from("evenements")
            .update({
              frequency_score: (chosen as any).frequency_score + 1 || 1,
              last_used: new Date().toISOString(),
            })
            .eq("id", chosen.id);

          setFallbackCountdown((prev) => prev - 1);
          return chosen;
        }

        // 6.4. Sinon => on prend un événement aléatoire
        const randomEvt =
          availableEvents[Math.floor(Math.random() * availableEvents.length)];
        if (randomEvt) {
          await updateGameState(randomEvt);
          setIsCountdownActive(true);

          await supabase
            .from("evenements")
            .update({
              frequency_score: (randomEvt as any).frequency_score + 1 || 1,
              last_used: new Date().toISOString(),
            })
            .eq("id", randomEvt.id);

          setFallbackCountdown((prev) => prev - 1);
          return randomEvt;
        }

        return null;
      }

      // 6.5. S’il y a des événements dans la plage stricte => sélection par difficulté [min..max]
      const { minDifficulty, maxDifficulty } = config.eventSelection;
      let selectedEvent: Event | null = null;
      let attempts = 0;
      const maxAttempts = 100;
      let currentMin = minDifficulty;
      let currentMax = maxDifficulty;

      // Boucle de recherche selon la difficulté (on élargit si on ne trouve rien)
      while (!selectedEvent && attempts < maxAttempts) {
        attempts++;

        const filteredByDiff = scoredEvents.filter(
          ({ event }) =>
            event.niveau_difficulte >= currentMin &&
            event.niveau_difficulte <= currentMax
        );

        if (filteredByDiff.length > 0) {
          const rndIdx = Math.floor(Math.random() * filteredByDiff.length);
          selectedEvent = filteredByDiff[rndIdx].event;
        } else {
          currentMin = Math.max(1, currentMin - 1);
          currentMax = Math.min(3, currentMax + 1);

          if (currentMin === 1 && currentMax === 3) {
            break; // on arrête si tout est déjà élargi
          }
        }
      }

      // Si toujours rien trouvé, on pioche au hasard dans la liste scoredEvents
      if (!selectedEvent) {
        selectedEvent =
          scoredEvents[Math.floor(Math.random() * scoredEvents.length)].event;
      }

      // Mise à jour du jeu avec l’événement sélectionné
      await updateGameState(selectedEvent);
      setIsCountdownActive(true);

      await supabase
        .from("evenements")
        .update({
          frequency_score: (selectedEvent as any).frequency_score + 1 || 1,
          last_used: new Date().toISOString(),
        })
        .eq("id", selectedEvent.id);

      // On décrémente le fallbackCountdown (mécanisme secondaire)
      setFallbackCountdown((prev) => prev - 1);

      return selectedEvent;
    },
    [
      user.level,
      usedEvents,
      fallbackCountdown,
      updateGameState,
      getTimeDifference,
      eventCount,
      forcedJumpEventCount,
      setForcedJumpEventCount,
      hasFirstForcedJumpHappened,
      setHasFirstForcedJumpHappened
    ]
  );

  // 1.H.5. updatePerformanceStats
  /**
   * 1.H.5. Met à jour les statistiques de performance de l’utilisateur
   * @function updatePerformanceStats
   * @param {string} type
   * @param {string} period
   * @param {boolean} success
   * @returns {void}
   */
  const updatePerformanceStats = useCallback((type: string, period: string, success: boolean) => {
    setPerformanceStats((prev) => {
      const typeSuccesses = Number(prev.typeSuccess[type]) || 0;
      const periodSuccesses = Number(prev.periodSuccess[period]) || 0;
      const totalAttemptsBefore = eventHistory.length;

      const typeSuccessRatio =
        (typeSuccesses + (success ? 1 : 0)) / (typeSuccesses + 1);

      const periodSuccessRatio =
        (periodSuccesses + (success ? 1 : 0)) / (periodSuccesses + 1);

      const overallAccuracy =
        (prev.overallAccuracy * totalAttemptsBefore + (success ? 1 : 0)) /
        (totalAttemptsBefore + 1);

      return {
        typeSuccess: {
          ...prev.typeSuccess,
          [type]: Number.isFinite(typeSuccessRatio) ? typeSuccessRatio : 0
        },
        periodSuccess: {
          ...prev.periodSuccess,
          [period]: Number.isFinite(periodSuccessRatio) ? periodSuccessRatio : 0
        },
        overallAccuracy: Number.isFinite(overallAccuracy)
          ? overallAccuracy
          : 0
      };
    });
  }, [eventHistory.length]);

  // 1.H.6. calculatePoints
  /**
   * 1.H.6. Calcule le nombre de points gagnés en fonction du temps, difficulté, streak, etc.
   * @function calculatePoints
   * @param {number} timeLeft
   * @param {number} difficulty
   * @param {number} streak
   * @param {string} eventType
   * @returns {number}
   */
  const calculatePoints = useCallback(
    (timeLeft: number, difficulty: number, streak: number, eventType: string): number => {
      try {
        const config = LEVEL_CONFIGS[user.level];
        const basePoints = config.scoring.basePoints * difficulty;

        const timeMultiplier = Math.min(
          1 + (timeLeft / 20) * config.scoring.timeMultiplier,
          2.5
        );
        const streakMultiplier = Math.min(
          1 + Math.floor(streak / config.scoring.comboThreshold) * config.scoring.streakMultiplier,
          3.0
        );

        const phaseMultiplier = 1; // Non utilisé pour l’instant

        const calculatedPoints = Math.floor(
          basePoints * timeMultiplier * streakMultiplier * phaseMultiplier
        );
        return Math.max(0, calculatedPoints);
      } catch (error) {
        return 0;
      }
    },
    [user.level]
  );

  // 1.H.7. applyReward
  /**
   * 1.H.7. Applique la récompense obtenue (vie supplémentaire, points, etc.)
   * @function applyReward
   * @param {{ type: RewardType; amount: number }} reward
   * @returns {void}
   */
  const applyReward = useCallback((reward: { type: RewardType; amount: number }) => {
    try {
      const safeAmount = Math.max(0, Math.floor(Number(reward.amount) || 0));
      setUser((prev) => {
        const currentPoints = Math.max(0, Number(prev.points) || 0);
        const updatedPoints = currentPoints + safeAmount;
        return {
          ...prev,
          points: updatedPoints,
          lives:
            reward.type === RewardType.EXTRA_LIFE
              ? Math.min(prev.lives + 1, MAX_LIVES)
              : prev.lives
        };
      });
    } catch (error) {
      // Rien
    }
  }, []);

  // 1.H.8. handleTimeout
  /**
   * 1.H.8. Gère la fin de timer (temps écoulé => perte de vie)
   * @function handleTimeout
   * @returns {void}
   */
  const handleTimeout = useCallback(() => {
    if (isLevelPaused) return;

    setUser((prev) => {
      const newLives = prev.lives - 1;
      if (newLives <= 0) {
        endGame();
        return { ...prev, lives: newLives, streak: 0 };
      }
      return {
        ...prev,
        lives: newLives,
        streak: 0
      };
    });

    setStreak(0);

    Animated.timing(progressAnim, {
      toValue: 0,
      duration: 500,
      useNativeDriver: false
    }).start();

    if (newEvent) {
      setPreviousEvent(newEvent);
      selectNewEvent(allEvents, newEvent);
    }
  }, [newEvent, allEvents, isLevelPaused, selectNewEvent, endGame, progressAnim]);

  /**
   * 1.H.9. handleChoice
   * Gère la réponse de l’utilisateur : "avant" ou "après"
   * @function handleChoice
   * @param {'avant' | 'après'} choice
   * @returns {void}
   */
  const handleChoice = useCallback(
    (choice: 'avant' | 'après') => {

      // 1) Vérifications préliminaires
      if (!previousEvent) {
        return;
      }
      if (!newEvent) {
        return;
      }
      if (isLevelPaused) {
        return;
      }

      // 2) Déterminer si la réponse est correcte (avant ou après)
      const previousDate = new Date(previousEvent.date);
      const newDate = new Date(newEvent.date);
      const newIsBefore = newDate < previousDate;  // "nouvel événement avant l'ancien ?"
      const newIsAfter = newDate > previousDate;   // "nouvel événement après l'ancien ?"

      const isAnswerCorrect =
        (choice === 'avant' && newIsBefore) ||
        (choice === 'après' && newIsAfter);

      // 3) On met à jour l'affichage : la date et le statut correct/incorrect
      setIsCorrect(isAnswerCorrect);
      setShowDates(true);

      // 4) Préparation de l'EventSummary
      const eventSummaryItem: LevelEventSummary = {
        id: newEvent.id,
        titre: newEvent.titre,
        date: newEvent.date,
        date_formatee: newEvent.date_formatee || newEvent.date,
        illustration_url: newEvent.illustration_url,
        wasCorrect: isAnswerCorrect,
        responseTime: 20 - timeLeft,
        description_detaillee: newEvent.description_detaillee,
      };

      // 5) On bloque temporairement les boutons (isWaitingForCountdown)
      setIsWaitingForCountdown(true);

      // ─────────────────────────────────────────────────────────────────────
      // CAS A : Réponse correcte
      // ─────────────────────────────────────────────────────────────────────
      if (isAnswerCorrect) {

        // a) Son, streak, animation
        playCorrectSound();
        const newStreak = streak + 1;
        setStreak(newStreak);

        Animated.timing(progressAnim, {
          toValue: newStreak,
          duration: 500,
          useNativeDriver: false,
        }).start(() => {
          // Barre de progression mise à jour
        });

        // b) Update performance stats
        updatePerformanceStats(
          newEvent.types_evenement?.[0] || 'default',
          getPeriod(newEvent.date),
          true
        );

        // c) Calcul des points
        const pts = calculatePoints(
          timeLeft,
          newEvent.niveau_difficulte || 1,
          newStreak,
          'default'
        );

        // d) Check des rewards (streak)
        checkRewards({ type: 'streak', value: newStreak }, user);

        // e) Mise à jour du user avec les points (si >0)
        if (Number.isFinite(pts) && pts > 0) {
          setUser((prev) => {
            const currentPoints = Math.max(0, Number(prev.points) || 0);
            const newPoints = currentPoints + pts;

            // On build un nouvel "user" local
            const updatedUser = {
              ...prev,
              points: newPoints,
              streak: newStreak,
              maxStreak: Math.max(prev.maxStreak, newStreak),
              eventsCompletedInLevel: prev.eventsCompletedInLevel + 1,
            };

            // Vérifier s'il faut monter de niveau
            if (updatedUser.eventsCompletedInLevel >= LEVEL_CONFIGS[prev.level].eventsNeeded) {
              const nextLevel = prev.level + 1;
              updatedUser.level = nextLevel;
              updatedUser.eventsCompletedInLevel = 0;

              // On marque la progression du niveau courant
              setPreviousEvent(newEvent);
              setLevelCompletedEvents((prevEvents) => [
                ...prevEvents,
                ...currentLevelEvents,
              ]);
              // On bascule sur la config du nouveau niveau
              setCurrentLevelConfig((prevConf) => ({
                ...LEVEL_CONFIGS[nextLevel],
                eventsSummary: [],
              }));
              setCurrentLevelEvents([]);
              setShowLevelModal(true);
              setIsLevelPaused(true);
              playLevelUpSound();

              // On check la reward (changement de level)
              checkRewards({ type: 'level', value: nextLevel }, updatedUser);

            } else {
              // Sinon, on stocke l'eventSummaryItem
              setCurrentLevelEvents((prevEvents) => [...prevEvents, eventSummaryItem]);

              // Au bout de 1.5s, on repasse isWaitingForCountdown à false, et on enchaîne
              setTimeout(() => {
                setIsWaitingForCountdown(false);

                if (!isGameOver && !showLevelModal) {
                  setPreviousEvent(newEvent);
                  selectNewEvent(allEvents, newEvent);
                }
              }, 750);
            }
            return updatedUser;
          });
        }

      // ─────────────────────────────────────────────────────────────────────
      // CAS B : Réponse incorrecte
      // ─────────────────────────────────────────────────────────────────────
      } else {

        // a) Son, streak=0, animation
        playIncorrectSound();
        setStreak(0);

        Animated.timing(progressAnim, {
          toValue: 0,
          duration: 500,
          useNativeDriver: false,
        }).start(() => {
          // Barre de progression remise à 0
        });

        // b) Stats
        updatePerformanceStats(
          newEvent.types_evenement?.[0] || 'default',
          getPeriod(newEvent.date),
          false
        );

        // c) On retire une vie
        setUser((prev) => {
          const updatedLives = prev.lives - 1;

          if (updatedLives <= 0) {
            endGame();
          }
          return {
            ...prev,
            lives: updatedLives,
            streak: 0,
          };
        });

        // d) On stocke l'eventSummaryItem
        setCurrentLevelEvents((prev) => [...prev, eventSummaryItem]);

        // e) Au bout de 1.5s, on repasse isWaitingForCountdown à false et on enchaîne
        setTimeout(() => {
          setIsWaitingForCountdown(false);

          if (!isGameOver && !showLevelModal) {
            setPreviousEvent(newEvent);
            selectNewEvent(allEvents, newEvent);
          }
        }, 1500);
      }
    },
    [
      previousEvent,
      newEvent,
      streak,
      timeLeft,
      isLevelPaused,
      isGameOver,
      showLevelModal,
      getPeriod,
      calculatePoints,
      playCorrectSound,
      playIncorrectSound,
      checkRewards,
      selectNewEvent,
      currentLevelEvents,
      endGame,
      updatePerformanceStats,
      allEvents,
      progressAnim,
      user,
    ]
  );

  /* ******* MODIFICATION ******* */
  // 1.H.10. handleLevelUp (correction du bug de type)
  const handleLevelUp = useCallback(() => {
    setUser(prevUser => {
      const nextLevel = prevUser.level + 1;
      const config = LEVEL_CONFIGS[nextLevel];
      if (!config) {
        return prevUser;
      }

      setCurrentLevelConfig(prevConf => ({
        ...config,
        eventsSummary: [...(prevConf?.eventsSummary || []), ...currentLevelEvents]
      }));

      setShowLevelModal(true);
      setIsLevelPaused(true);
      setIsCountdownActive(false);
      setCurrentLevelEvents([]);

      const reward: { type: RewardType; amount: number } = {
        type: RewardType.POINTS,
        amount: config.pointsReward || 500
      };
      applyReward(reward);
      saveProgress();

      return {
        ...prevUser,
        level: nextLevel
      };
    });
  }, [currentLevelEvents, applyReward, saveProgress]);

  // 1.H.11. endGame
  /**
   * 1.H.11. Termine la partie et sauvegarde le score (classements)
   * @async
   * @function endGame
   * @returns {Promise<void>}
   */
  const endGame = useCallback(async () => {
    setIsGameOver(true);
    playGameOverSound();
    setLeaderboardsReady(false);

    try {
      const { data: { user: authUser } } = await supabase.auth.getUser();
      
      // Mode invité
      if (!authUser?.id) {
        const guestScores = {
          daily: [{
            name: user.name || 'Voyageur',
            score: user.points,
            rank: 1
          }],
          monthly: [{
            name: "👑 Meilleur score",
            score: 12500,
            rank: 1
          }],
          allTime: [{
            name: "🏆 Record",
            score: 25000,
            rank: 1
          }]
        };
        
        setLeaderboards(guestScores);
        setLeaderboardsReady(true);
        return;
      }

      // Mode utilisateur connecté
      const today = new Date().toISOString().split('T')[0];
      const firstDayOfMonth = `${today.substring(0, 7)}-01`;

      await supabase.from('game_scores').insert({
        user_id: authUser.id,
        display_name: user.name,
        score: user.points,
        created_at: new Date().toISOString()
      });

      const { data: dailyScores } = await supabase
        .from('game_scores')
        .select('display_name, score')
        .gte('created_at', today)
        .order('score', { ascending: false })
        .limit(5);

      const { data: monthlyScores } = await supabase
        .from('game_scores')
        .select('display_name, score')
        .gte('created_at', firstDayOfMonth)
        .order('score', { ascending: false })
        .limit(5);

      const { data: allTimeScores } = await supabase
        .from('profiles')
        .select('display_name, high_score')
        .order('high_score', { ascending: false })
        .limit(5);

      const { data: currentProfile } = await supabase
        .from('profiles')
        .select('high_score')
        .eq('id', authUser.id)
        .single();

      if (currentProfile && user.points > currentProfile.high_score) {
        await supabase
          .from('profiles')
          .update({ high_score: user.points })
          .eq('id', authUser.id);
      }

      if (dailyScores && monthlyScores && allTimeScores) {
        setScoresAndShow(dailyScores, monthlyScores, allTimeScores);
      }
      await saveProgress();
    } catch (error) {
      // En cas d'erreur, afficher au moins les scores de l'invité
      const fallbackScores = {
        daily: [{
          name: user.name || 'Voyageur',
          score: user.points,
          rank: 1
        }],
        monthly: [{
          name: "👑 Meilleur score",
          score: 12500,
          rank: 1
        }],
        allTime: [{
          name: "🏆 Record",
          score: 25000,
          rank: 1
        }]
      };
      
      setLeaderboards(fallbackScores);
      setLeaderboardsReady(true);
    }
  }, [user, playGameOverSound, saveProgress]);

  // 1.H.12. saveProgress
  /**
   * 1.H.12. Sauvegarde le progrès (niveau, score)
   * @async
   * @function saveProgress
   * @returns {Promise<void>}
   */
  const saveProgress = useCallback(async () => {
    try {
      const { data: { user: authUser } } = await supabase.auth.getUser();
      if (!authUser) return;

      const saveData = {
        high_score: Math.max(user.points, highScore),
        current_level: user.level,
        total_events_completed: user.totalEventsCompleted,
        last_played: new Date().toISOString()
      };
      await supabase.from('profiles').update(saveData).eq('id', authUser.id);
    } catch (error) {
      // Gestion des erreurs si nécessaire
    }
  }, [user.points, user.level, user.totalEventsCompleted, highScore]);

  // 1.H.13. setScoresAndShow
  /**
   * 1.H.13. Met en forme les tableaux de scores et affiche le leaderboard
   * @function setScoresAndShow
   * @param {any[]} dailyScores
   * @param {any[]} monthlyScores
   * @param {any[]} allTimeScores
   * @returns {void}
   */
  const setScoresAndShow = (
    dailyScores: any[],
    monthlyScores: any[],
    allTimeScores: any[]
  ) => {
    const formatted = {
      daily: dailyScores.map((score, index) => ({
        name: score.display_name.trim(),
        score: score.score,
        rank: index + 1
      })),
      monthly: monthlyScores.map((score, index) => ({
        name: score.display_name.trim(),
        score: score.score,
        rank: index + 1
      })),
      allTime: allTimeScores.map((score, index) => ({
        name: score.display_name.trim(),
        score: score.high_score || 0,
        rank: index + 1
      }))
    };
    setLeaderboards(formatted);
    setLeaderboardsReady(true);
  };

  /* ******* MODIFICATION ******* */
  // 1.H.15. startLevel
  /**
   * 1.H.15. Lance le niveau (ferme le modal et relance la sélection d’événements)
   * @function startLevel
   * @returns {void}
   */
  const startLevel = useCallback(() => {
    setShowLevelModal(false);
    setIsLevelPaused(false);
    setIsCountdownActive(true);
    setTimeLeft(20);

    setLevelCompletedEvents([]); // On vide les événements du niveau terminé

    if (previousEvent) {
      selectNewEvent(allEvents, previousEvent);
    } else {
      // Aucun événement précédent, aucune action spécifique définie
    }
  }, [allEvents, previousEvent, selectNewEvent]);


  /* 1.I. Retour du hook */
  return {
    user,
    previousEvent,
    newEvent,
    timeLeft,
    loading,
    error,
    isGameOver: isGameOver && leaderboardsReady,
    showDates,
    isCorrect,
    isImageLoaded,
    streak,
    highScore,
    showLevelModal,
    isLevelPaused,
    currentLevelConfig,
    leaderboards,
    performanceStats,
    categoryMastery,
    periodStats,
    activeBonus,

    currentReward,
    completeRewardAnimation,
    updateRewardPosition,

    handleChoice,
    startLevel,
    handleLevelUp,

    remainingEvents: allEvents.length - usedEvents.size,

    progressAnim,

    onImageLoad: handleImageLoad,

    /* ******* NOUVELLE VALEUR RETOURNÉE ******* */
    levelCompletedEvents,
  };
}



// ============= kiko-info/hooks/useRewards.ts =============
import { useState, useCallback } from 'react';
import { RewardType, User, MAX_LIVES } from './types/index';
import { LEVEL_CONFIGS } from './levelConfigs';

interface Position {
  x: number;
  y: number;
}
interface Reward {
  type: RewardType;
  amount: number;
  reason: string;
  sourcePosition?: Position;
  targetPosition?: Position;
}
interface RewardTrigger {
  type: 'streak' | 'level' | 'precision';
  value: number;
}
interface UseRewardsProps {
  onRewardEarned?: (reward: Reward) => void;
  onRewardAnimationComplete?: () => void;
}

const debugLogs = { /* ... invariable, comme avant ... */ };

export const useRewards = ({
  onRewardEarned,
  onRewardAnimationComplete
}: UseRewardsProps = {}) => {

  const [currentReward, setCurrentReward] = useState<Reward | null>(null);
  const [isAnimating, setIsAnimating] = useState(false);

  // 1) On va plus se servir de la file d’attente : on la supprime ou la met en commentaire
  // Pour vraiment empêcher les enchaînements multiples, on refuse toute nouvelle reward si isAnimating est true
  // const [pendingRewards, setPendingRewards] = useState<Reward[]>([]);

  // A. Calcul Streak (multiples de 10)
  const calculateStreakReward = useCallback((streak: number, user: User): Reward | null => {
    if (streak % 10 !== 0) return null;
    const multiplier = Math.floor(streak / 10);
    const basePoints = 100;
    const pointsAmount = basePoints * multiplier;

    const canGiveLife = user.lives < MAX_LIVES;

    return {
      type: canGiveLife ? RewardType.EXTRA_LIFE : RewardType.POINTS,
      amount: canGiveLife ? 1 : pointsAmount,
      reason: `Série de ${streak} bonnes réponses !`
    };
  }, []);

  // B. Calcul Level
  const calculateLevelReward = useCallback((newLevel: number, user: User): Reward | null => {
    if (isNaN(newLevel) || newLevel <= 0) return null;
    const levelConfig = LEVEL_CONFIGS[newLevel];
    if (!levelConfig) return null;

    const canGiveLife = user.lives < MAX_LIVES;
    return {
      type: canGiveLife ? RewardType.EXTRA_LIFE : RewardType.POINTS,
      amount: canGiveLife ? 1 : (levelConfig.pointsReward || 1000),
      reason: `Niveau ${newLevel} atteint !`
    };
  }, []);

  // C. “processNextReward” n’est plus utile si on n’a pas de file d’attente

  // D. checkRewards
  const checkRewards = useCallback((trigger: RewardTrigger, user: User) => {
    // Si on est déjà en train d’animer => on ignore
    if (isAnimating) {
      return;
    }

    let reward: Reward | null = null;

    switch (trigger.type) {
      case 'streak':
        reward = calculateStreakReward(trigger.value, user);
        break;
      case 'level':
        reward = calculateLevelReward(trigger.value, user);
        break;
      default:
        break;
    }

    if (!reward) {
      return;
    }

    // On commence direct l’animation
    setCurrentReward(reward);
    setIsAnimating(true);

    // On notifie immédiatement le parent
    if (onRewardEarned) {
      onRewardEarned(reward);
    }

  }, [
    isAnimating,
    calculateStreakReward,
    calculateLevelReward,
    onRewardEarned
  ]);

  // E. completeRewardAnimation
  const completeRewardAnimation = useCallback(() => {
    setCurrentReward(null);
    setIsAnimating(false);

    if (onRewardAnimationComplete) {
      onRewardAnimationComplete();
    }
  }, [onRewardAnimationComplete]);

  // F. updateRewardPosition
  const updateRewardPosition = useCallback((position: Position) => {
    if (!currentReward) return;
    setCurrentReward(prev => prev ? { ...prev, targetPosition: position } : null);
  }, [currentReward]);

  return {
    currentReward,
    isAnimating,
    checkRewards,
    completeRewardAnimation,
    updateRewardPosition,
  };
};

export default useRewards;



// ============= kiko-info/types/index.ts =============
// 1. Interfaces Principales du Jeu
// =============================
// Cette section définit les types de base nécessaires au fonctionnement du jeu

// 1.A. Interface Utilisateur
// -------------------------
// Définit les propriétés de base d'un utilisateur dans le jeu
export interface User {
    name: string;
    points: number;
    lives: number;
    level: number;
    streak: number;
    maxStreak: number;
    eventsCompletedInLevel: number;
    totalEventsCompleted: number;
    performanceStats: PerformanceStats;
  }
  
  // 1.B. Interface Événement
  // -----------------------
  // Définit la structure d'un événement historique dans le jeu
  export interface Event {
    id: string;
    date: string;
    titre: string;
    illustration_url: string;
    date_formatee?: string;
    universel: boolean;
    niveau_difficulte: number;
    types_evenement: string[];
    description?: string;
    period: HistoricalPeriod;
  }
  
  // 1.C. Interface Statistiques de Performance
  // ----------------------------------------
  export interface PerformanceStats {
    typeSuccess: Record<string, number>;
    periodSuccess: Record<string, number>;
    overallAccuracy: number;
    averageResponseTime: number;
  }
  
  // 1.D. Interface résumé événements
  export interface LevelEventSummary {
    id: string;
    titre: string;
    date: string;
    date_formatee: string;
    illustration_url: string;
    wasCorrect: boolean;
    responseTime?: number;
  }
  
  // 2. Systèmes de Jeu
  // ==================
  
  // 2.A. Périodes Historiques
  export enum HistoricalPeriod {
    ANTIQUITY = "Antiquité",
    MIDDLE_AGES = "Moyen Âge",
    RENAISSANCE = "Renaissance",
    NINETEENTH = "XIX",
    TWENTIETH = "XX",
    TWENTYFIRST = "XXI"
  }
  
  // 2.B. Système de Récompenses
  export enum RewardType {
    POINTS = "POINTS",
    EXTRA_LIFE = "EXTRA_LIFE",
    STREAK_BONUS = "STREAK_BONUS",
    LEVEL_UP_BONUS = "LEVEL_UP_BONUS"
  }
  
  export interface Reward {
    type: RewardType;
    amount: number;
    reason: string;
  }

  // 2.B.1 Système de Bonus
export enum BonusType {
  TIME = "TIME",
  STREAK = "STREAK",
  PERIOD = "PERIOD",
  MASTERY = "MASTERY",
  COMBO = "COMBO"
}

export interface ActiveBonus {
  type: BonusType;
  multiplier: number;
  duration: number;
  expiresAt: number;
}
  
  // 2.C. Système de Niveaux
  export enum SpecialRules {
    ADAPTIVE_DIFFICULTY = "ADAPTIVE_DIFFICULTY",
    FLEX_TIME_GAP = "FLEX_TIME_GAP",
    BONUS_MULTIPLIER = "BONUS_MULTIPLIER",
    STREAK_FOCUS = "STREAK_FOCUS"
  }
  
  export interface LevelConfig {
    level: number;
    name: string;
    description: string;
    eventsNeeded: number;
    timeGap: {
        base: number;
        variance: number;
        minimum: number;
        minGap?: number;
    };
    eventSelection: {
        minDifficulty: number;    
        maxDifficulty: number;    
        universalOnly: boolean;   
        specialEventChance: number; 
        relaxationFactor?: number;  
    };
    scoring: {
        basePoints: number;       
        streakMultiplier: number; 
        timeMultiplier: number;   
        comboThreshold: number;   
    };
    specialRules?: SpecialRules[];
    pointsReward?: number;
    eventsSummary?: LevelEventSummary[];
  }
  
  export interface ExtendedLevelConfig extends LevelConfig {
    eventsSummary: LevelEventSummary[];
  }
  
  export const DEFAULT_LEVEL_CONFIG: Partial<LevelConfig> = {
    timeGap: {
        base: 400,
        variance: 100,
        minimum: 300,
        minGap: 300
    },
    eventSelection: {
        minDifficulty: 1,
        maxDifficulty: 10,
        universalOnly: false,
        specialEventChance: 0,
        relaxationFactor: 0.5
    },
    scoring: {
        basePoints: 100,
        streakMultiplier: 1.0,
        timeMultiplier: 1.0,
        comboThreshold: 2
    }
  };
  
  // 3. Constantes et Configurations
  export const MAX_LIVES = 3;
  export const BASE_POINTS = 100;
  export const MIN_TIME_BONUS = 0.8;
  export const MAX_TIME_BONUS = 1.5;
  export const MAX_STREAK_BONUS = 2.0;
  
  // 4. Interfaces Utilitaires
  export interface LevelPerformance {
    accuracy: number;
    averageTime: number;
    streakLength: number;
    perfectRounds: number;
    specialEventsCompleted: number;
  }
  
  export interface DifficultyModifiers {
    timeGapModifier: number;
    eventDifficultyModifier: number;
    scoringModifier: number;
  }
  
  export interface TimeGapCalculator {
    getMinGap: (level: number, performance: number) => number;
    getMaxGap: (level: number, performance: number) => number;
  }
  
  export interface DifficultyCalculator {
    getRange: (level: number, performance: number) => {
        min: number;
        max: number;
    };
  }
  
  export interface EventSelector {
    filterEligibleEvents: (
        events: Event[],
        currentEvent: Event,
        criteria: {
            minGap: number;
            maxGap: number;
            difficultyRange: { min: number; max: number };
        }
    ) => Event[];
  }
  
  // 4.C. Types Utilitaires
  export type LevelConfigType = typeof LEVEL_CONFIGS[keyof typeof LEVEL_CONFIGS];
  export type SpecialRuleType = keyof typeof SpecialRules;


// ============= kiko-info/app/(tabs)/index.tsx =============
import React, { useEffect, useState, useRef } from 'react';
import {
  View,
  Text,
  Image,
  StyleSheet,
  StatusBar,
  Alert,
  Animated,
  Easing,
  Dimensions,
  Platform,
} from 'react-native';
import { useRouter } from 'expo-router';
import { supabase } from '../../lib/supabase/supabaseClients';
import { Audio } from 'expo-av';
import { LinearGradient } from 'expo-linear-gradient';
import { User } from '@supabase/supabase-js';
import { Pressable } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { BannerAd, BannerAdSize, TestIds } from 'react-native-google-mobile-ads';

const { width, height } = Dimensions.get('window');

// Theme configuration
const THEME = {
  primary: '#050B1F',    // Très sombre Navy Blue
  secondary: '#0A173D',  // Navy Blue profond
  accent: '#FFCC00',     // Or Métallique
  text: '#FFFFFF',
  background: {
    dark: '#020817',     // Presque noir avec une teinte bleue
    medium: '#050B1F',   // Très sombre
    light: '#0A173D'     // Navy Blue profond
  },
  button: {
    primary: ['#1D5F9E', '#0A173D'],    // Gradient Blue to Dark
    secondary: ['#FFBF00', '#CC9900'],   // Gradient Gold to Dark Gold
    tertiary: ['#0A173D', '#1D5F9E']     // Dark to Blue
  }
};

const AnimatedButton = React.memo(({ 
  onPress, 
  label, 
  icon, 
  variant = 'primary',
  disabled = false,
  style = {} 
}) => {
  const scale = useRef(new Animated.Value(1)).current;
  const translateY = useRef(new Animated.Value(0)).current;

  const animatePress = (pressed) => {
    Animated.parallel([
      Animated.spring(scale, {
        toValue: pressed ? 0.95 : 1,
        tension: 100,
        friction: 5,
        useNativeDriver: true
      }),
      Animated.spring(translateY, {
        toValue: pressed ? 2 : 0,
        tension: 100,
        friction: 5,
        useNativeDriver: true
      })
    ]).start();
  };

  const getGradientColors = () => {
    switch (variant) {
      case 'primary': return THEME.button.primary;
      case 'secondary': return THEME.button.secondary;
      default: return THEME.button.tertiary;
    }
  };

  return (
    <Pressable
      onPressIn={() => animatePress(true)}
      onPressOut={() => animatePress(false)}
      onPress={onPress}
      disabled={disabled}
    >
      <Animated.View style={[
        styles.buttonWrapper,
        {
          transform: [
            { scale },
            { translateY }
          ],
          opacity: disabled ? 0.6 : 1
        },
        style
      ]}>
        <LinearGradient
          colors={getGradientColors()}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
          style={styles.buttonContainer}
        >
          {icon && (
            <Ionicons 
              name={icon} 
              size={24} 
              color="white" 
              style={styles.buttonIcon}
            />
          )}
          <Text style={styles.buttonText}>{label}</Text>
        </LinearGradient>
      </Animated.View>
    </Pressable>
  );
});

export default function HomeScreen() {
  const router = useRouter();
  const [user, setUser] = useState<User | null>(null);
  const [displayName, setDisplayName] = useState('');
  const [guestDisplayName, setGuestDisplayName] = useState<string | null>(null);

  // Animation refs
  const mainContentAnimation = {
    opacity: useRef(new Animated.Value(0)).current,
    translateY: useRef(new Animated.Value(50)).current
  };

  // Sélection de l'ID de test approprié selon la plateforme
  const adUnitId = Platform.select({
    android: TestIds.BANNER,
    ios: TestIds.BANNER,
    default: TestIds.BANNER,
  });

  useEffect(() => {
    checkUser();
    animateMainContent();
  }, []);

  const animateMainContent = () => {
    Animated.parallel([
      Animated.spring(mainContentAnimation.opacity, {
        toValue: 1,
        friction: 8,
        useNativeDriver: true
      }),
      Animated.spring(mainContentAnimation.translateY, {
        toValue: 0,
        friction: 8,
        tension: 40,
        useNativeDriver: true
      })
    ]).start();
  };

  const checkUser = async () => {
    const { data: { session } } = await supabase.auth.getSession();
    if (session?.user) {
      setUser(session.user);
      await fetchUserProfile(session.user.id);
    }
  };

  const fetchUserProfile = async (userId: string) => {
    const { data, error } = await supabase
      .from('profiles')
      .select('display_name')
      .eq('id', userId)
      .single();
      
    if (data) setDisplayName(data.display_name);
  };

  const handleLogout = async () => {
    try {
      await supabase.auth.signOut();
      setGuestDisplayName(null);
      setDisplayName('');
      setUser(null);
    } catch (error) {
      Alert.alert('Erreur', 'Impossible de se déconnecter');
    }
  };

  const handlePlayAsGuest = () => {
    const guestId = Math.floor(Math.random() * 10000);
    const name = `Voyageur-${guestId}`;
    setGuestDisplayName(name);
    Alert.alert(
      'Mode Découverte', 
      `Bienvenue, ${name} ! En mode découverte, votre progression ne sera pas sauvegardée.`,
      [{ text: "OK" }]
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar translucent backgroundColor="transparent" barStyle="light-content" />

      <LinearGradient
        colors={[THEME.background.dark, THEME.background.medium]}
        style={styles.mainContainer}
      >
        <Animated.View style={[
          styles.contentContainer,
          {
            opacity: mainContentAnimation.opacity,
            transform: [{ translateY: mainContentAnimation.translateY }]
          }
        ]}>
          <View style={styles.headerContainer}>
            <Text style={styles.welcomeTitle}>
              {guestDisplayName || displayName 
                ? `Bienvenue, ${guestDisplayName || displayName}`
                : "L'Histoire vous Attend"}
            </Text>
            <Text style={styles.welcomeSubtitle}>
              {(user || guestDisplayName)
                ? "Prêt pour votre prochaine aventure ?"
                : "Embarquez pour un voyage fascinant"}
            </Text>
          </View>

          {(user || guestDisplayName) ? (
            <>
              <AnimatedButton
                label="Commencer l'Aventure"
                icon="rocket-outline"
                onPress={() => router.push('/vue1')}
                variant="primary"
              />
              <AnimatedButton
                label="Déconnexion"
                icon="log-out-outline"
                onPress={handleLogout}
                variant="secondary"
              />
            </>
          ) : (
            <>
              <AnimatedButton
                label="Se Connecter"
                icon="log-in-outline"
                onPress={() => router.push('/auth/login')}
                variant="primary"
              />
              <AnimatedButton
                label="Créer un Compte"
                icon="person-add-outline"
                onPress={() => router.push('/auth/signup')}
                variant="secondary"
              />
              <AnimatedButton
                label="Mode Découverte"
                icon="compass-outline"
                onPress={handlePlayAsGuest}
                variant="tertiary"
              />
            </>
          )}

          {/* Bannière publicitaire en bas */}
          <View style={styles.adContainer}>
            <BannerAd
              unitId={adUnitId}
              size={BannerAdSize.BANNER}
              requestOptions={{
                requestNonPersonalizedAdsOnly: true,
              }}
            />
          </View>
        </Animated.View>
      </LinearGradient>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: THEME.background.dark,
  },
  mainContainer: {
    flex: 1,
  },
  contentContainer: {
    flex: 1,
    paddingTop: Platform.OS === 'ios' ? 60 : 40,
    paddingHorizontal: 20,
    justifyContent: 'center',
  },
  headerContainer: {
    alignItems: 'center',
    marginBottom: 50,
  },
  welcomeTitle: {
    fontSize: 32,
    fontFamily: 'Montserrat-Bold',
    color: THEME.text,
    textAlign: 'center',
    marginBottom: 10,
  },
  welcomeSubtitle: {
    fontSize: 18,
    fontFamily: 'Montserrat-Regular',
    color: THEME.text,
    opacity: 0.8,
    textAlign: 'center',
  },
  buttonWrapper: {
    marginVertical: 10,
    width: '100%',
    alignSelf: 'center',
  },
  buttonContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    borderRadius: 15,
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
  },
  buttonIcon: {
    marginRight: 10,
  },
  buttonText: {
    color: THEME.text,
    fontSize: 18,
    fontFamily: 'Montserrat-Bold',
  },
  adContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 20,
    marginBottom: Platform.OS === 'ios' ? 40 : 20,
  },
});


// ============= kiko-info/app/(tabs)/explore.tsx =============
import { StyleSheet, Image, Platform } from 'react-native';

import { Collapsible } from '@/components/Collapsible';
import { ExternalLink } from '@/components/ExternalLink';
import ParallaxScrollView from '@/components/ParallaxScrollView';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';

export default function TabTwoScreen() {
  return (
    <ParallaxScrollView
      headerBackgroundColor={{ light: '#D0D0D0', dark: '#353636' }}
      headerImage={
        <IconSymbol
          size={310}
          color="#808080"
          name="chevron.left.forwardslash.chevron.right"
          style={styles.headerImage}
        />
      }>
      <ThemedView style={styles.titleContainer}>
        <ThemedText type="title">Explore</ThemedText>
      </ThemedView>
      <ThemedText>This app includes example code to help you get started.</ThemedText>
      <Collapsible title="File-based routing">
        <ThemedText>
          This app has two screens:{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/index.tsx</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">app/(tabs)/explore.tsx</ThemedText>
        </ThemedText>
        <ThemedText>
          The layout file in <ThemedText type="defaultSemiBold">app/(tabs)/_layout.tsx</ThemedText>{' '}
          sets up the tab navigator.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/router/introduction">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Android, iOS, and web support">
        <ThemedText>
          You can open this project on Android, iOS, and the web. To open the web version, press{' '}
          <ThemedText type="defaultSemiBold">w</ThemedText> in the terminal running this project.
        </ThemedText>
      </Collapsible>
      <Collapsible title="Images">
        <ThemedText>
          For static images, you can use the <ThemedText type="defaultSemiBold">@2x</ThemedText> and{' '}
          <ThemedText type="defaultSemiBold">@3x</ThemedText> suffixes to provide files for
          different screen densities
        </ThemedText>
        <Image source={require('@/assets/images/react-logo.png')} style={{ alignSelf: 'center' }} />
        <ExternalLink href="https://reactnative.dev/docs/images">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Custom fonts">
        <ThemedText>
          Open <ThemedText type="defaultSemiBold">app/_layout.tsx</ThemedText> to see how to load{' '}
          <ThemedText style={{ fontFamily: 'SpaceMono' }}>
            custom fonts such as this one.
          </ThemedText>
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/versions/latest/sdk/font">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Light and dark mode components">
        <ThemedText>
          This template has light and dark mode support. The{' '}
          <ThemedText type="defaultSemiBold">useColorScheme()</ThemedText> hook lets you inspect
          what the user's current color scheme is, and so you can adjust UI colors accordingly.
        </ThemedText>
        <ExternalLink href="https://docs.expo.dev/develop/user-interface/color-themes/">
          <ThemedText type="link">Learn more</ThemedText>
        </ExternalLink>
      </Collapsible>
      <Collapsible title="Animations">
        <ThemedText>
          This template includes an example of an animated component. The{' '}
          <ThemedText type="defaultSemiBold">components/HelloWave.tsx</ThemedText> component uses
          the powerful <ThemedText type="defaultSemiBold">react-native-reanimated</ThemedText>{' '}
          library to create a waving hand animation.
        </ThemedText>
        {Platform.select({
          ios: (
            <ThemedText>
              The <ThemedText type="defaultSemiBold">components/ParallaxScrollView.tsx</ThemedText>{' '}
              component provides a parallax effect for the header image.
            </ThemedText>
          ),
        })}
      </Collapsible>
    </ParallaxScrollView>
  );
}

const styles = StyleSheet.create({
  headerImage: {
    color: '#808080',
    bottom: -90,
    left: -35,
    position: 'absolute',
  },
  titleContainer: {
    flexDirection: 'row',
    gap: 8,
  },
});



// ============= kiko-info/app/(tabs)/_layout.tsx =============
import 'react-native-reanimated';
import { Stack } from 'expo-router';

export default function RootLayout() {
  return (
    <Stack 
      screenOptions={{ 
        headerShown: false,
        animation: 'slide_from_right'
      }}
    >
      <Stack.Screen 
        name="(tabs)" 
        options={{
          headerShown: false,
        }}
      />
      <Stack.Screen 
        name="auth" 
        options={{
          headerShown: false,
        }}
      />
    </Stack>
  );
}


// ============= kiko-info/app/auth/signup.tsx =============
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  Platform
} from 'react-native';
import { supabase } from '../../lib/supabase/supabaseClients';
import { router } from 'expo-router';

const THEME = {
  primary: '#050B1F',
  secondary: '#0A173D',
  accent: '#FFCC00',
  text: '#FFFFFF',
  background: {
    dark: '#020817',
    medium: '#050B1F',
    light: '#0A173D'
  },
  button: {
    primary: ['#1D5F9E', '#0A173D'],
    secondary: ['#FFBF00', '#CC9900'],
    tertiary: ['#0A173D', '#1D5F9E']
  }
};

export default function SignUp() {
  const [nickname, setNickname] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errorMessage, setErrorMessage] = useState('');
  const [successMessage, setSuccessMessage] = useState('');
  const [isSigningUp, setIsSigningUp] = useState(false);

  const handleSignUp = async () => {
    if (isSigningUp) return;

    console.log('🔐 Starting signup process...');
    setIsSigningUp(true);
    setErrorMessage('');
    setSuccessMessage('');

    // 1. Validation de base des champs
    if (!nickname.trim()) {
      setErrorMessage('Le pseudonyme est obligatoire.');
      setIsSigningUp(false);
      return;
    }

    // 2. Vérification de la longueur du pseudonyme (max 12 caractères)
    if (nickname.trim().length > 12) {
      setErrorMessage('Le pseudonyme ne peut pas dépasser 12 caractères.');
      setIsSigningUp(false);
      return;
    }

    // (Optionnel) Vérification de certains caractères spéciaux interdits
    const forbiddenChars = /[\\\/]/g;
    if (forbiddenChars.test(nickname)) {
      setErrorMessage('Le pseudonyme contient des caractères interdits (\\ ou /).');
      setIsSigningUp(false);
      return;
    }

    if (!email.trim()) {
      setErrorMessage("L'email est obligatoire.");
      setIsSigningUp(false);
      return;
    }

    if (!password || password.length < 6) {
      setErrorMessage('Le mot de passe doit contenir au moins 6 caractères.');
      setIsSigningUp(false);
      return;
    }

    try {
      // 3. Vérification si le pseudo est déjà utilisé en base
      //    (Requiert que ta table "profiles" ait une colonne "display_name".)
      const { data: existingProfile, error: checkProfileError } = await supabase
        .from('profiles')
        .select('id')
        .eq('display_name', nickname.trim())
        .single();

      // Erreur inattendue lors de la vérification du pseudo
      if (checkProfileError && checkProfileError.code !== 'PGRST116') {
        console.error('❌ Check nickname error:', checkProfileError.message);
        setErrorMessage('Erreur lors de la vérification du pseudonyme.');
        setIsSigningUp(false);
        return;
      }

      // Si un profil existe déjà avec ce pseudo
      if (existingProfile) {
        setErrorMessage('Ce pseudonyme est déjà utilisé. Veuillez en choisir un autre.');
        setIsSigningUp(false);
        return;
      }

      // 4. Inscription de l'utilisateur (Supabase se charge de vérifier l’unicité de l’email)
      const { data, error: signUpError } = await supabase.auth.signUp({
        email: email.trim(),
        password: password,
        options: {
          data: {
            display_name: nickname.trim(),
          },
        },
      });

      if (signUpError) {
        console.error('❌ Signup error:', signUpError.message);
        // Supabase renvoie une erreur si l'email est déjà utilisée
        if (signUpError.message.includes('Email')) {
          setErrorMessage('Cet email est invalide ou déjà utilisé.');
        } else {
          setErrorMessage(signUpError.message);
        }
        return;
      }

      if (!data.user) {
        setErrorMessage('Erreur lors de la création du compte.');
        return;
      }

      // 5. Création du profil utilisateur avec des valeurs par défaut
      const { error: profileError } = await supabase
        .from('profiles')
        .insert([
          {
            id: data.user.id,
            display_name: nickname.trim(),
            high_score: 0,
            games_played: 0,
            current_level: 1,
            events_completed: 0,
            mastery_levels: {},
            is_admin: false
          }
        ]);

      if (profileError) {
        console.error('❌ Profile creation error:', profileError.message);
        setErrorMessage('Erreur lors de la création du profil. Veuillez réessayer.');
        return;
      }

      // 6. Succès et navigation
      setSuccessMessage('Compte créé avec succès!');

      // Attendre un peu pour que l'utilisateur voie le message de succès
      setTimeout(() => {
        try {
          router.push('/(tabs)');
        } catch (navError) {
          console.error('❌ Navigation error:', navError);
          // Le compte est créé, on ne montre pas d'erreur supplémentaire
        }
      }, 1500);

    } catch (error) {
      console.error('❌ Unexpected error:', error);
      setErrorMessage('Une erreur inattendue est survenue.');
    } finally {
      setIsSigningUp(false);
    }
  };

  return (
    <ScrollView
      contentContainerStyle={styles.container}
      keyboardShouldPersistTaps="handled"
    >
      <Text style={styles.title}>Inscription</Text>

      <TextInput
        style={styles.input}
        placeholder="Pseudonyme"
        placeholderTextColor={`${THEME.text}66`}
        value={nickname}
        onChangeText={setNickname}
        autoCapitalize="none"
        autoComplete="username"
      />

      <TextInput
        style={styles.input}
        placeholder="Email"
        placeholderTextColor={`${THEME.text}66`}
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
        autoComplete="email"
      />

      <TextInput
        style={styles.input}
        placeholder="Mot de passe"
        placeholderTextColor={`${THEME.text}66`}
        secureTextEntry
        value={password}
        onChangeText={setPassword}
        autoComplete="password-new"
      />

      {errorMessage ? (
        <Text style={styles.error}>{errorMessage}</Text>
      ) : null}

      {successMessage ? (
        <Text style={styles.success}>{successMessage}</Text>
      ) : null}

      <TouchableOpacity
        style={[styles.button, isSigningUp && styles.buttonDisabled]}
        onPress={handleSignUp}
        disabled={isSigningUp}
      >
        <Text style={styles.buttonText}>
          {isSigningUp ? "Création du compte..." : "S'inscrire"}
        </Text>
      </TouchableOpacity>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flexGrow: 1,
    backgroundColor: THEME.background.dark,
    padding: 20,
    justifyContent: 'center',
    paddingTop: Platform.OS === 'ios' ? 60 : 40,
  },
  title: {
    fontSize: 28,
    color: THEME.accent,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
  },
  input: {
    backgroundColor: THEME.secondary,
    color: THEME.text,
    fontSize: 16,
    padding: 12,
    marginBottom: 15,
    borderRadius: 8,
    width: '100%',
  },
  button: {
    backgroundColor: THEME.button.secondary[0],
    padding: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 15,
    width: '100%',
  },
  buttonDisabled: {
    opacity: 0.7,
  },
  buttonText: {
    color: THEME.text,
    fontSize: 16,
    fontWeight: 'bold',
  },
  error: {
    color: 'red',
    marginVertical: 10,
    textAlign: 'center',
  },
  success: {
    color: '#4CAF50',
    marginVertical: 10,
    textAlign: 'center',
    fontWeight: 'bold',
  },
});



// ============= kiko-info/app/auth/login.tsx =============
import React, { useState, useEffect, useLayoutEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Switch,
  StyleSheet,
  Platform,
  SafeAreaView,
  StatusBar,
  Dimensions
} from 'react-native';
import { supabase } from '../../lib/supabase/supabaseClients';
import { router, useNavigation, usePathname, useSegments } from 'expo-router';

const THEME = {
  primary: '#050B1F',
  secondary: '#0A173D',
  accent: '#FFCC00',
  text: '#FFFFFF',
  background: {
    dark: '#020817',
    medium: '#050B1F',
    light: '#0A173D'
  },
  button: {
    primary: ['#1D5F9E', '#0A173D'],
    secondary: ['#FFBF00', '#CC9900'],
    tertiary: ['#0A173D', '#1D5F9E']
  }
};

export default function Login() {
  const navigation = useNavigation();
  const pathname = usePathname();
  const segments = useSegments();
  const window = Dimensions.get('window');

  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errorMessage, setErrorMessage] = useState('');
  const [stayConnected, setStayConnected] = useState(false);
  const [isLoggingIn, setIsLoggingIn] = useState(false);

  useLayoutEffect(() => {
    const options = {
      headerShown: false,
      title: '',
      headerTitle: '',
      header: null,
    };
    navigation.setOptions(options);
  }, [navigation]);

  useEffect(() => {
    StatusBar.setBarStyle('light-content');
    if (Platform.OS === 'android') {
      StatusBar.setBackgroundColor(THEME.background.dark);
    }
    console.log('🔍 Login Screen Mounted');
    console.log('📍 Current pathname:', pathname);
    console.log('🔀 Current segments:', segments);

    return () => {
      console.log('🔍 Login Screen Unmounted');
    };
  }, []);

  const handleLogin = async () => {
    console.log('🔐 Starting login process...');
    setIsLoggingIn(true);
    setErrorMessage('');
  
    try {
      console.log('📧 Attempting login with email:', email.trim());
      const { data, error } = await supabase.auth.signInWithPassword({
        email: email.trim(),
        password: password,
      });
  
      console.log('📊 Login response:', { 
        user: !!data?.user, 
        session: !!data?.session, 
        error: !!error 
      });
  
      if (error) {
        console.error('❌ Login error:', error.message);
        if (error.message.toLowerCase().includes('invalid login credentials')) {
          setErrorMessage(
            "Identifiants incorrects ou compte inexistant.\nVeuillez vérifier vos informations ou créer un compte."
          );
        } else {
          setErrorMessage(error.message);
        }
        return;
      }
  
      if (data?.session) {
        console.log('✅ Session created successfully');
        
        if (stayConnected) {
          console.log('🔄 Setting persistent session');
          await supabase.auth.setSession(data.session);
        }
  
        // Essayons différentes approches de navigation
        console.log('🚀 Attempting navigation...');
        
        try {
          // Approche 1: Navigation directe
          router.push('/(tabs)');
          console.log('✅ Navigation approach 1 completed');
        } catch (e1) {
          console.error('❌ Navigation approach 1 failed:', e1);
          
          try {
            // Approche 2: Navigation avec délai
            setTimeout(() => {
              router.replace('/(tabs)');
              console.log('✅ Navigation approach 2 completed');
            }, 100);
          } catch (e2) {
            console.error('❌ Navigation approach 2 failed:', e2);
            
            try {
              // Approche 3: Navigation absolue
              navigation.navigate('(tabs)');
              console.log('✅ Navigation approach 3 completed');
            } catch (e3) {
              console.error('❌ All navigation approaches failed');
              console.error(e3);
              setErrorMessage("Erreur lors de la redirection. Veuillez réessayer.");
            }
          }
        }
  
      } else {
        console.error('❌ No session created');
        setErrorMessage("Erreur lors de la connexion. Veuillez réessayer.");
      }
    } catch (err) {
      console.error('❌ Unexpected error:', err);
      setErrorMessage('Une erreur est survenue. Veuillez réessayer.');
    } finally {
      console.log('🏁 Login process completed');
      setIsLoggingIn(false);
    }
  };

  const handleGoToSignUp = () => {
    router.push('/auth/signup');
  };

  return (
    <SafeAreaView style={styles.safeArea}>
      <View style={styles.container}>
        <Text style={styles.title}>Connexion</Text>

        <TextInput
          style={styles.input}
          placeholder="Email"
          placeholderTextColor={`${THEME.text}66`}
          value={email}
          onChangeText={(text) => setEmail(text)}
          keyboardType="email-address"
          autoCapitalize="none"
          autoComplete="email"
        />

        <TextInput
          style={styles.input}
          placeholder="Mot de passe"
          placeholderTextColor={`${THEME.text}66`}
          secureTextEntry
          value={password}
          onChangeText={(text) => setPassword(text)}
          autoComplete="password"
        />

        <View style={styles.stayConnectedContainer}>
          <Switch
            trackColor={{ false: '#767577', true: THEME.accent }}
            thumbColor={stayConnected ? THEME.secondary : '#f4f3f4'}
            ios_backgroundColor="#3e3e3e"
            value={stayConnected}
            onValueChange={(value) => setStayConnected(value)}
          />
          <Text style={styles.stayConnectedText}>Rester connecté</Text>
        </View>

        {errorMessage ? <Text style={styles.errorText}>{errorMessage}</Text> : null}

        <TouchableOpacity
          style={[styles.button, isLoggingIn && { opacity: 0.7 }]}
          onPress={handleLogin}
          disabled={isLoggingIn}
        >
          <Text style={styles.buttonText}>
            {isLoggingIn ? 'Connexion...' : 'Se connecter'}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.createAccountButton}
          onPress={handleGoToSignUp}
        >
          <Text style={styles.createAccountText}>Créer un compte</Text>
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: THEME.background.dark,
  },
  container: {
    flex: 1,
    backgroundColor: THEME.background.dark,
    padding: 20,
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    color: THEME.accent,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
  },
  input: {
    backgroundColor: THEME.secondary,
    color: THEME.text,
    fontSize: 16,
    padding: 12,
    marginBottom: 15,
    borderRadius: 8,
    width: '100%',
  },
  stayConnectedContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  stayConnectedText: {
    color: THEME.text,
    marginLeft: 8,
    fontSize: 16,
  },
  errorText: {
    color: 'red',
    marginVertical: 10,
    textAlign: 'center',
  },
  button: {
    backgroundColor: THEME.button.secondary[0],
    padding: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 15,
    width: '100%',
  },
  buttonText: {
    color: THEME.text,
    fontSize: 16,
    fontWeight: 'bold',
  },
  createAccountButton: {
    marginTop: 20,
    alignItems: 'center',
  },
  createAccountText: {
    color: THEME.accent,
    fontSize: 16,
    textDecorationLine: 'underline',
  },
});


// ============= kiko-info/app/auth/_layout.tsx =============
import { Stack } from 'expo-router';
import { useEffect } from 'react';
import { Platform } from 'react-native';

export default function AuthLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        animation: 'slide_from_right',
        contentStyle: {
          backgroundColor: 'transparent'
        }
      }}
    >
      <Stack.Screen 
        name="login"
        options={{
          headerShown: false,
        }}
      />
      <Stack.Screen 
        name="signup"
        options={{
          headerShown: false,
        }}
      />
    </Stack>
  );
}


// ============= kiko-info/app/game/page.tsx =============



// ============= kiko-info/lib/supabase/database.types.ts =============
export interface Database {
    public: {
      Tables: {
        profiles: {
          Row: {
            id: string
            display_name: string
            high_score: number
            games_played: number
            current_level: number
            events_completed: number
            is_admin: boolean
            created_at?: string
            updated_at?: string
          }
          Insert: {
            id: string
            display_name: string
            high_score?: number
            games_played?: number
            current_level?: number
            events_completed?: number
            is_admin?: boolean
          }
          Update: {
            id?: string
            display_name?: string
            high_score?: number
            games_played?: number
            current_level?: number
            events_completed?: number
            is_admin?: boolean
          }
        }
      }
    }
  }


// ============= kiko-info/lib/supabase/supabaseClients.ts =============
import 'react-native-url-polyfill/auto';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from '@supabase/supabase-js';
import { Database } from './database.types';

const supabaseUrl = 'https://ppxmtnuewcixbbmhnzzc.supabase.co';
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBweG10bnVld2NpeGJibWhuenpjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjY4OTkxMjcsImV4cCI6MjA0MjQ3NTEyN30.0z2be74E3db-XvyIKXPlogI__9Ric1Il4cZ1Fs7TJ5U';

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});


// ============= kiko-info/components/ui/IconSymbol.ios.tsx =============
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}



// ============= kiko-info/components/ui/TabBarBackground.tsx =============
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}



// ============= kiko-info/components/ui/TabBarBackground.ios.tsx =============
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}



// ============= kiko-info/components/ui/IconSymbol.tsx =============
// This file is a fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight } from 'expo-symbols';
import React from 'react';
import { OpaqueColorValue, StyleProp, ViewStyle } from 'react-native';

// Add your SFSymbol to MaterialIcons mappings here.
const MAPPING = {
  // See MaterialIcons here: https://icons.expo.fyi
  // See SF Symbols in the SF Symbols app on Mac.
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as Partial<
  Record<
    import('expo-symbols').SymbolViewProps['name'],
    React.ComponentProps<typeof MaterialIcons>['name']
  >
>;

export type IconSymbolName = keyof typeof MAPPING;

/**
 * An icon component that uses native SFSymbols on iOS, and MaterialIcons on Android and web. This ensures a consistent look across platforms, and optimal resource usage.
 *
 * Icon `name`s are based on SFSymbols and require manual mapping to MaterialIcons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}



// ============= kiko-info/components/game/GameContentA.tsx =============



// ============= kiko-info/components/game/UserInfo.tsx =============
import React, { forwardRef, useImperativeHandle, useEffect, useRef, useState } from 'react';
import { View, Text, StyleSheet, Platform, Animated } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { colors } from '../../constants/colors';
import { MAX_LIVES, ActiveBonus, BonusType } from '../../hooks/types';

// Interface des props
interface UserInfoProps {
  name: string;
  points: number;
  lives: number;
  level: number;
  streak: number;
  activeBonus?: ActiveBonus[];
}

// Interface des méthodes exposées
export interface UserInfoHandle {
  getPointsPosition: () => Promise<{ x: number; y: number }>;
  getLifePosition: () => Promise<{ x: number; y: number }>;
}

// Composant UserInfo
const UserInfo = forwardRef<UserInfoHandle, UserInfoProps>(
  ({ name, points, lives, level, streak, activeBonus = [] }, ref) => {
    const pointsRef = useRef<Text>(null);
    const livesRef = useRef<View>(null);
    const bounceAnim = useRef(new Animated.Value(1)).current;

    // State pour stocker les positions
    const [pointsPosition, setPointsPosition] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
    const [livesPosition, setLivesPosition] = useState<{ x: number; y: number }>({ x: 0, y: 0 });

    // Animation des points
    useEffect(() => {
      Animated.sequence([
        Animated.spring(bounceAnim, {
          toValue: 1.1,
          friction: 3,
          tension: 40,
          useNativeDriver: true,
        }),
        Animated.spring(bounceAnim, {
          toValue: 1,
          friction: 3,
          useNativeDriver: true,
        }),
      ]).start();
    }, [points]);

    // Calcul des positions après le rendu
    useEffect(() => {
      const measurePositions = () => {
        requestAnimationFrame(() => {
          if (pointsRef.current) {
            pointsRef.current.measure((x, y, width, height, pageX, pageY) => {
              const position = { x: pageX + width / 2, y: pageY + height / 2 };
              setPointsPosition(position);
            });
          }

          if (livesRef.current) {
            livesRef.current.measure((x, y, width, height, pageX, pageY) => {
              const position = { x: pageX + width / 2, y: pageY + height / 2 };
              setLivesPosition(position);
            });
          }
        });
      };

      measurePositions();
    }, [lives, points]); // Dépendances

    // Exposition des méthodes pour obtenir les positions
    useImperativeHandle(ref, () => ({
      getPointsPosition: () => {
        if (!pointsRef.current) {
          return Promise.resolve({ x: 0, y: 0 });
        }
        return Promise.resolve(pointsPosition);
      },
      getLifePosition: () => {
        if (!livesRef.current) {
          return Promise.resolve({ x: 0, y: 0 });
        }
        return Promise.resolve(livesPosition);
      },
    }));

    // Fonctions utilitaires (getBonusColor, getBonusIcon)
    const getBonusColor = (type: BonusType) => {
      switch (type) {
        case BonusType.TIME:
          return colors.timerNormal;
        case BonusType.STREAK:
          return colors.warningYellow;
        case BonusType.PERIOD:
          return colors.primary;
        case BonusType.MASTERY:
          return colors.accent;
        case BonusType.COMBO:
          return colors.correctGreen;
        default:
          return colors.primary;
      }
    };

    const getBonusIcon = (type: BonusType): string => {
      switch (type) {
        case BonusType.TIME:
          return 'timer-outline';
        case BonusType.STREAK:
          return 'flame-outline';
        case BonusType.PERIOD:
          return 'calendar-outline';
        case BonusType.MASTERY:
          return 'star-outline';
        case BonusType.COMBO:
          return 'flash-outline';
        default:
          return 'star-outline';
      }
    };

    // Rendu des indicateurs de bonus
    const renderBonusIndicators = () => {
      const currentTime = Date.now();
      const activeMultipliers = activeBonus.filter(
        (bonus) => bonus.expiresAt > currentTime
      );

      if (activeMultipliers.length === 0) return null;

      return (
        <View style={styles.bonusContainer}>
          {activeMultipliers.map((bonus, index) => (
            <View key={index} style={styles.bonusItem}>
              <View style={styles.bonusIconContainer}>
                <Ionicons
                  name={getBonusIcon(bonus.type)}
                  size={16}
                  color={getBonusColor(bonus.type)}
                />
                <Text style={[styles.bonusMultiplier, { color: getBonusColor(bonus.type) }]}>
                  x{bonus.multiplier.toFixed(1)}
                </Text>
              </View>
              <View style={styles.bonusProgressContainer}>
                <View
                  style={[
                    styles.bonusProgress,
                    {
                      width: `${((bonus.expiresAt - currentTime) / bonus.duration) * 100}%`,
                      backgroundColor: getBonusColor(bonus.type),
                    },
                  ]}
                />
              </View>
            </View>
          ))}
        </View>
      );
    };

    // Rendu des vies
    const renderLives = () => (
      <View ref={livesRef} style={styles.livesContainer}>
        {Array(MAX_LIVES)
          .fill(0)
          .map((_, i) => (
            <Animated.View
              key={i}
              style={[
                styles.heartContainer,
                i < lives && {
                  transform: [{ scale: bounceAnim }],
                },
              ]}
            >
              <Ionicons
                name={i < lives ? 'heart' : 'heart-outline'}
                size={18}
                color={i < lives ? colors.incorrectRed : colors.lightText}
                style={styles.heart}
              />
            </Animated.View>
          ))}
      </View>
    );

    // Rendu du streak
    const renderStreak = () => (
      <View style={styles.streakContainer}>
        <Text style={[
          styles.streakText,
          streak >= 20 ? styles.streakUltra :
          streak >= 15 ? styles.streakMaster : 
          streak >= 10 ? styles.streakExpert :
          streak >= 5 ? styles.streakPro : null
        ]}>
          {streak > 0 ? `×${streak}` : ''}
        </Text>
      </View>
    );

    // Gestion des couleurs de niveau
    const getLevelColor = (level: number): string => {
      if (level <= 5) return colors.primary;
      if (level <= 10) return colors.accent;
      if (level <= 15) return colors.warningYellow;
      return colors.incorrectRed;
    };

    // Rendu principal
    return (
      <View style={styles.container}>
        <View style={styles.mainSection}>
          <View style={styles.userInfo}>
            <Text style={styles.userName}>{name || ''}</Text>
            <Text ref={pointsRef} style={styles.score}>{points}</Text>
          </View>
          <View style={styles.statsContainer}>
            {renderLives()}
            <View style={[styles.levelBadge, { backgroundColor: getLevelColor(level) }]}>
              <Text style={styles.levelText}>{level}</Text>
            </View>
            {renderStreak()}
            {renderBonusIndicators()}
          </View>
        </View>
      </View>
    );
  }
);

// Styles
const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 10,
    backgroundColor: 'transparent',
    flex: 1,
  },
  mainSection: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  statsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 'auto',
    gap: 8,
  },
  userInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8,
  },
  userName: {
    fontSize: 14,
    fontWeight: 'bold',
    color: colors.darkText,
    marginRight: 6,
  },
  score: {
    fontSize: 14,
    color: colors.primary,
    fontWeight: '600',
    paddingHorizontal: 6,
    paddingVertical: 3,
  },
  livesContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  levelBadge: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 10,
    flexDirection: 'row',
    alignItems: 'center',
  },
  levelText: {
    color: 'white',
    fontSize: 12,
    fontWeight: 'bold',
  },
  streakContainer: {
    minWidth: 24,
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 4,
  },
  streakText: {
    color: colors.darkText,
    fontSize: 14,
    fontWeight: 'bold',
  },
  streakPro: {
    color: colors.primary,
  },
  streakExpert: {
    color: colors.accent,
  },
  streakMaster: {
    color: colors.warningYellow,
  },
  streakUltra: {
    color: colors.incorrectRed,
  },
  bonusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 10, // Espacement à gauche pour séparer des autres éléments
  },
  bonusItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 5, // Espacement entre les bonus
  },
  bonusIconContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 2, // Espacement entre l'icône et le multiplicateur
  },
  bonusMultiplier: {
    fontSize: 14,
    fontWeight: 'bold',
    marginLeft: 2,
  },
  bonusProgressContainer: {
    height: 6, // Hauteur de la barre de progression
    width: 50, // Largeur de la barre de progression
    backgroundColor: colors.lightGrey, // Couleur de fond de la barre
    borderRadius: 3, // Bords arrondis pour la barre
    overflow: 'hidden', // Assure que la barre de progression ne dépasse pas les bords
  },
  bonusProgress: {
    height: '100%', // La barre de progression remplit la hauteur du conteneur
    borderRadius: 3, // Bords arrondis pour la barre
  },
});

export default UserInfo;



// ============= kiko-info/components/game/Countdown.tsx =============
import React, { useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Animated } from 'react-native';
import { colors } from '@/constants/colors';

interface CountdownProps {
  timeLeft: number;
  isActive?: boolean;
}

const Countdown: React.FC<CountdownProps> = ({ timeLeft, isActive = true }) => {
  const scaleAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    if (isActive) {
      if (timeLeft <= 5) {
        // Animation de pulse pour les dernières 5 secondes
        Animated.sequence([
          Animated.timing(scaleAnim, {
            toValue: 1.2,
            duration: 200,
            useNativeDriver: true,
          }),
          Animated.timing(scaleAnim, {
            toValue: 1,
            duration: 200,
            useNativeDriver: true,
          }),
        ]).start();
      }
    }
  }, [timeLeft, isActive]);

  const getBackgroundColor = () => {
    if (!isActive) return colors.lightText;
    if (timeLeft > 14) return colors.timerNormal;
    if (timeLeft > 7) return colors.warningYellow;
    return colors.incorrectRed;
  };

  return (
    <Animated.View
      style={[
        styles.container,
        { 
          backgroundColor: getBackgroundColor(),
          transform: [{ scale: scaleAnim }]
        },
      ]}
    >
      <Text style={styles.text}>{timeLeft}</Text>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.23,
    shadowRadius: 2.62,
  },
  text: {
    color: colors.white,
    fontSize: 20,
    fontWeight: 'bold',
    textAlign: 'center',
  }
});

export default Countdown;


// ============= kiko-info/components/game/OverlayChoiceButtonsA.tsx =============
import React, { useEffect, useState, useRef } from 'react';
import { View, TouchableOpacity, Text, StyleSheet, Animated, Dimensions } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { colors } from '@/constants/colors';

const { width } = Dimensions.get('window');

interface OverlayChoiceButtonsAProps {
  onChoice: (choice: 'avant' | 'après') => void;
  isLevelPaused: boolean;
  isWaitingForCountdown?: boolean;
  transitioning?: boolean;
}

const OverlayChoiceButtonsA: React.FC<OverlayChoiceButtonsAProps> = ({
  onChoice,
  isLevelPaused,
  isWaitingForCountdown = false,
  transitioning = false
}) => {
  const [buttonClicked, setButtonClicked] = useState(false);
  const [justAnswered, setJustAnswered] = useState(false);
  const fadeAnim = useRef(new Animated.Value(1)).current;

  const handlePress = (choice: 'avant' | 'après') => {
    if (!isLevelPaused && !transitioning && !isWaitingForCountdown && !buttonClicked && !justAnswered) {
      setButtonClicked(true);
      setJustAnswered(true);
      onChoice(choice);

      // Prolonger le verrou justAnswered
      setTimeout(() => {
        setJustAnswered(false);
      }, 750);
    }
  };

  // Reset buttonClicked après 500ms
  useEffect(() => {
    if (buttonClicked) {
      const timer = setTimeout(() => {
        setButtonClicked(false);
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [buttonClicked]);

  // Fade OUT si l'une des conditions est vraie
  useEffect(() => {
    const shouldFadeOut = isLevelPaused || isWaitingForCountdown || transitioning || buttonClicked || justAnswered;

    Animated.timing(fadeAnim, {
      toValue: shouldFadeOut ? 0 : 1,
      duration: 300,
      useNativeDriver: true,
    }).start();
  }, [isLevelPaused, isWaitingForCountdown, transitioning, buttonClicked, justAnswered]);

  const pointerEvents =
    !isLevelPaused && !isWaitingForCountdown && !transitioning && !buttonClicked && !justAnswered
      ? 'auto'
      : 'none';

  return (
    <Animated.View style={[styles.container, { opacity: fadeAnim }]} pointerEvents={pointerEvents}>
      <TouchableOpacity
        onPress={() => handlePress('avant')}
        activeOpacity={0.8}
        style={styles.button}
      >
        <LinearGradient
          colors={['#6e6e6e', '#5a5a5a', '#4a4a4a']}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
          style={styles.buttonGradient}
        >
          <Text style={styles.buttonText}>AVANT</Text>
        </LinearGradient>
      </TouchableOpacity>

      <TouchableOpacity
        onPress={() => handlePress('après')}
        activeOpacity={0.8}
        style={styles.button}
      >
        <LinearGradient
          colors={['#6e6e6e', '#5a5a5a', '#4a4a4a']}
          start={{ x: 0, y: 0 }}
          end={{ x: 1, y: 1 }}
          style={styles.buttonGradient}
        >
          <Text style={styles.buttonText}>APRÈS</Text>
        </LinearGradient>
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    marginVertical: 10,
    width: '100%',
  },
  button: {
    borderRadius: 25,
    overflow: 'hidden',
    width: '40%',
  },
  buttonGradient: {
    padding: 12,
    alignItems: 'center',
    borderRadius: 25,
  },
  buttonText: {
    color: colors.white,
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
    textTransform: 'uppercase',
    letterSpacing: 1,
  },
});

export default OverlayChoiceButtonsA;


// ============= kiko-info/components/game/EventLayoutA.tsx =============



// ============= kiko-info/components/game/AnimatedEventCardA.tsx =============



